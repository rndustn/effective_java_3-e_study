# 8장. 메서드

- [ ]  메서드 설계시 주의할 점 살펴보기
- [ ]  매개변수와 반환값 처리 방법
- [ ]  메서드 시그니처 설계 방법
- [ ]  문서화 방법

# 아이템49. 매개변수가 유효한지 검사하라

- 매개변수 제약은 반드시 문서화해야하며 메서드 몸체가 시작되기 전에 검사해야 한다.
- 매개변수 검사에 실패하면 실패원자성(failure atomicity)을 어기는 결과를 낳을 수 있다.
- public 과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.

    (@throws 자바독 태그 사용)

- 매개변수의 제약을 문서화 할 때 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.
- 자바7에 추가된 java.util.Objects.requireNonNull 메서드
    - 더이상  null 검사를 수동으로 하지 않아도 된다.
    - 원하는 예외 메시지 지정 가능
    - 입력을 그대로 반환하므로 값을 사용하는 동시에  null검사를 수행할 수 있다.

    ```java
    this.strategy = Objects.requireNonNull(strategy, "전략");
    ```

- 자바9에서는 Objects에 범위 검사 기능이 추가되었다.
    - checkFromIndexSize, checkFromToIndex, checkIndex
    - null검사 메서드 만큼 유연하지 않다.
    - 예외 메시지 지정 불가
    - 리스트와 배열 전용
    - 닫힌 범위(양 끝단 값을 포함하는)는 다루지 못한다.
- public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다.

    ```java
    private static void sort(long a[], int offset, int length){
    	assert a!= null;
    	assert offset >= 0 && offset <= a.length;
    	assert length >= 0 && length <= a.length - offset;
    	...
    }
    ```

    - 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다.
    - 실패하면 AssertionError를 던진다.
    - 런타임에 아무런 효과도, 성능저하도 없다.
- 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.
    - ex) 배열의 list를 반환하는 메서드 → null 검사를 생략하면 반환된 리스트를 클라이언트가 사용할때가 되서야 예외를 발생시켜 list를 어디서 가져왔는지 추척하기 어렵다.
    - 위 사항의 특수한 사례 : 생성자 → 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.
- 메서드 몸체 실행 전에 유효성을 검사해야한다는 규칙의 예외사항
    - 유효성 검사 비용이 지나치게 높거나 실용적이지 않은 경우
    - 계산과정에서 암묵적으로 검사가 수행되는 경우
- 메서드는 최대한 범용적으로 설계해야 하기때문에 매개변수 제약은 적을 수록 좋기때문에 필요한 경우에만 제약을 두어야 한다.

# 아이템50. 적시에 방어적 복사본을 만들라

## 불변식을 깨뜨리지 않도록 방어적으로 프로그래밍 해야한다.

불변식을 지키지 못한 기간 표현 클래스 예시

```java
public final class Period{
	private final Date start;
	private final Date end;
	public Period(Date start, Date end){
		if(start.comparTo(end) > 0){
			throw new IllegalArgumentException();
		}
		this.start = start;
		this.end = end;
	}
	public Date start(){ return start; }
	public Date end(){ return end; }
	...
}
```

- Date가 가변이기 때문에 아래와 같이 공격이 가능하다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p의 내부 수정 가능
```

- java8 이후로는 Date 대신 불변인 Instant를 사용하거나, LocalDateTime, ZonedDateTime을 사용한다.
- Date는 더 이상 사용하지 않도록 한다.

## 외부공격으로부터 Period 인스턴스 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.

Period 인스턴스 안에서는 원본이 아닌 복사본을 사용해야 한다.

```java
public Period(Date start, Date end){
	this.start = new Date(start.getTime());
	this.end = new Date(end.getTime());
	if(this.start.comparTo(this.end) > 0){
		throw new IllegalArgumentException();
	}
}
```

- **매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사하는 순서로 해야한다.**

    → 멀티 스레드 환경에서는 원본 객체의 유효성을 검사한 후 복사본을 만드는 찰나의 순간에도 다른 스레드가 원본을 수정할 위험이 있기 때문이다.

- 방어적 복사에 Date의 clone메서드를 사용하지 않는다.

    → Date는 final이 아니므로 clone이 Date가 정의한 게 아닐 수 있다. 즉, clone이 악의를 가진 하위 클래스의 인스턴스를 반환할 수 있다.

- **매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.**
- Period는 접근자 메서드가 내부의 가변 정보를 직접 드러내기 때문에 아직 공격이 유효하다.

    → 접근자가 가변 필드의 방어적 복사본을 반환하도록 수정하면 된다.

    ```java
    public Date start(){ return new Date(start.getTime());}
    public Date end(){ return new Date(end.getTime());}
    ```

    생성자와 달리 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다.

    → Period가 가진 Date객체는 java.util.Date임이 확실하기 때문이다.

    **그래도 인스턴스를 복사하는 데는 생성자나 정적 팩터리를 쓰는게 좋다.**

## 방어적 복사가 필요한 경우

1. 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지 따져봐야 한다. → 확신할 수 없다면 복사본 만들어 저장해야 한다.
2. 길이가 1 이상인 배열은 무조건 가변이다. → 내부에서 사용하는 배열을 클라이언트에 반화할 때 항상 방어적 복사를 수행해야 한다.

## ✏️핵심정리

- 되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다.
- 호출자가 컴포넌트 내부를 수정하지 않는다 확신하면 방어적 복사 생략 가능하다 → 방어적복사는 성능저하가 따르고, 또 항상 사용할 수 있지도 않다.(같은 패키지에 속하는 경우)
- 방어적 복사를 생략해도 되는 상황은 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때, 혹은 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때로 한정해야 한다.

# 아이템51. 메서드 시그니처를 신중히 설계하라.

## 1. 메서드 이름을 신중이 짓자.

- 표준 명명 규칙을 따라야 한다.
- 이해하기 쉽고, 일관성 있게 지어야 한다.

## 2. 편의 메서드를 너무 많이 만들기 말자.

- 메서드가 너무 많으면 익히고, 사용, 문서화, 테스트, 유지보수가 어렵다.
- 클래스나 인터페이스는 자신의 각 기능을 완벽히 수행하는 메서드로 제공해야 한다.
- 아주 자주 쓰일 경우에만 별도의 약칭 메서드를 둔다.

## 3. 매개변수 목록은 짧게 유지하자.

- 4개 이하가 좋다. → 많으면 기억하기 어렵다.
- 같은 타입의 매개변수 여러 개가 연달아 나오는 경우 특히 해롭다. → 실수로 순서를 바꾸면 오작동한다.
- 매개변수 목록을 짧게 줄여주는 기술 세가지
    1. 원래 매개변수 목록의 부분집합을 받는 여러 메서드로 쪼갠다.

        ex) java.util.List → 지정 범위의 부분리스트에서 주어진 원소의 인덱스 찾는 경우 : subList, indexOf

    2. 매개변수 여러 개를 묶어주는 도우미 클래스를 만든다.
        - 도우미 클래스는 정적 멤버 클래스로 둔다.
        - 잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있을 경우 추천

            ex) 카드게임을 클래스로 만들 때 항상 같은 순서로 전달되는 숫자와 무늬 매개변수를 묶는 도우미

    3. 1,2번 혼합한 것으로 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용한다.
        - 매개변수가 많을 때, 특히 그중 일부는 생략해도 괜찮을 때 도움된다.

        수행 절차

        1. 모든 매개변수를 하나로 추상화한 객체를 정의하고, 클라이언트에서 이 객체의 세터메서드를 호출해 필요한 값을 설정하게 한다.
        2. 이때 각 세터 메서드는 매개변수 하나 혹은 서로 연관된 몇 개만 설정하게 한다.
        3. 클라이언트는 먼저 필요한 매개변수를 다 설정한다.
        4. execute 메서드를 호출해 앞서 설정한 매개변수들의 유효성을 검사한다.
        5. 설정이 완료된 객체를 넘겨 원하는 계산을 수행한다.

## 4. 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다.

- 매개변수로 적합한 인터페이스가 있다면(이를 구현한 클래스가 아닌) 그 인터페이스를 직접 사용하자.

    ex) 메서드에 HashMap을 넘길 일은 전혀 없다. 대신 Map을 사용한다.

    → HashMap뿐만 아니라 TreeMap, ConcurrentHashMap, TreeMap의 부분맵 등 어떤 Map 구현체도 인수로 건넬 수 있다.

- 아직 존재하지 않는 Map 구현체도 인수로 넘길 수 있다.
- 인터페이스 대신 클래스를 사용하는 것은 특정 구현체만 인수로 넘기도록 제한하는 것이다.

    → 입력 데이터의 타입이 다르면 특정 구현체로 변경해야 한다.

## 5. boolean보다는 원소 2개짜리 열거 타입이 낫다.

- 코드를 읽고 쓰기 더 쉬워진다.
- 나중에 선택지 추가가 쉽다.

# 아이템52. 다중정의는 신중히 사용하라.

## 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다.

- 메서드를 다중정의하면 어느 메서드를 호출할지가 매개변수의 컴파일타임 타입을 기준으로 정해진다.
- 메서드를 재정의하면 해당 객체의 런타임 타입이 어떤 메서드를 호출할지의 기준이 된다.
- 다중정의 문제는 메서드를 하나로 합치고 instanceof로 명시적 검사하면 해결된다.

    ```java
    public static String classify(Collection<?>c){
    	return c instanceof Set ? "집합":
    				 c instanceof List ? "리스트" : "그 외";
    }
    ```

## 다중정의시 주의할 점

1. 다중정의가 혼동을 일으키는 상황을 피해야 한다.
2. 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.

    가변인수를 사용하는 메서드라면 다중정의를 아예 사용하지 말자.

3. 다중정의하는 대신 메서드 이름을 다르게 지어준다.

    ex) ObjectOutputStream클래스의 write메서드

    - 다중정의 대신 타입별로 다른 이름의 메서드 생성
    - writeBoolean, writeInt, writeLong 등

## 생성자 - 이름을 다르게 지을 수 없다.

- 생성자는 이름을 다르게 지을 수 없어 두 번째 생성자부터는 무조건 다중정의가 된다.
- 정적 팩터리라는 대안을 활용한다.
- 생성자는 재정의 불가

### 여러 생성자가 같은 수의 매개변수를 받아야하는 경우 안전 대책

매개변수 중 **하나 이상이 타입의 값을 서로 어느쪽으로든 형변환 할 수 없다**는 조건만 충족하면 매개변수들의 런타임 타입만으로 호출되는 메서드가 결정된다.

ex) ArrayList 클래스에 있는 int를 받는 생성자와 Collection을 받는 생성자 둘은 어느것이 호출될 지 헷갈리지 않는다.

## 제네릭과 오토박싱이 추가된 후 List 인터페이스 사용시 주의할 점

0~5까지 들어있는 set과 list를 비교하면

set.remove()의 시그니처는 remove(Object) 여서 remove(3)하면 3이라는 값이 제거된다.

list.remove()는 remove(Object)와 remove(int index)가 다중정의되어 있어 index가 3인 2값이 제거된다.

해결 : list.remove((Integer)i) 혹은 remove(Integer.valueOf(i)) 로 Object 타입으로 변환해야 한다.

## 람다와 메서드 참조가 추가된 후 주의할 점

**메서드를 다중정의할 때, 서로 다른 함수형 인터페이스도 같은 위치의 인수로 받아서는 안 된다.**

```java
// 1번. Thread의 생성자 호출
new Thread(System.out::println).start();
// 2번. ExecutorService의 submit 메서드 호출
ExecutorService exec = Executors.newCachedThreadPool();
exec.submit(System.out::println);
```

- 2번만 컴파일 오류난다.
- 원인: submit 다중정의 메서드 중에는 Callable<T>를 받는 메서드도 있다.
- 참조된 메서드(println)와 호출한 메서드(submit) 양쪽 다 다중정의되어, 다중정의 해소 알고리즘이 제대로 작동하지 않는다.

## Forword

어떤 다중정의 메서드가 호출될지 몰라도 기능이 똑같다면 신경 쓸 필요 없다.

이런 경우 더 특수한 메서드에서 더 일반적인 메서드로 포워드해주어 동일한 일을 하도록 보장해준다.

```java
public boolean contentEquals(StringBuffer sb){
	return contentEquals((CharSequence)sb);
}
```

## ✏️핵심정리

- 매개변수 수가 같을 때는 오버로딩을 피해야 한다.
- 생성자와 같이 오버로딩해야하는 경우엔 헷갈릴 만한 매개변수는 형변환하여 정확한 오버로딩메서드가 선택되도록 한다.
- 위 방법이 불가한, 기존 클래스를 수정해 새로운 인터페이스를 구현해야할 때는 같은 객체를 입력받는 오버로딩 메서드들이 모두 동일하게 동작하도록 만들어야 한다.

# 아이템53. 가변인수는 신중히 사용하라

- 가변인수 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있다.
- 가변인수 메서드를 호출하면, 먼저 인수의 개수와 길이가 같은 배열을 만들고, 저장하여 메서드에 건넨다.
- 인수 개수는 런타임에 자동생성된 배열의 길이로 알 수 있다.

## 인수가 1개 이상이어야 할 경우

1. 잘못된 예

    ```jsx
    static int min(int ...args){
    	if(args.length == 0) throw new IllegalArgumentException("인수 1개 이상 필요");
    	int min = args[0]; //또는 Integer.MAX_VALUE
    ...
    }
    ```

2. 1. 수정

    ```jsx
    static int min(int firstArg, int ... remainingArgs){
    	int min = firstArg;
    }
    ```

이와같이 가변인수는 인수 개수가 정해지지 않았을 때 유용하다.

- printf와 리플렉션 모두 가변인수 덕을 본다.

## 성능에 민감한 상황이면 가변인수가 걸림돌 될 수 있다.

- 가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화 한다.
- 가변인수의 유연성이 필요할 때 사용하는 패턴 → 다중정의
    - ex)호출의 95%가 인수를 3개 이하로 사용하면 인수 0~3개까지 호출하는 메서드 다중정의하고, 4개부터 가변인수로 호출하는 것이다.

## ✏️핵심정리

- 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다.
- 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 둔다.

# 아이템54. null이 아닌, 빈 컬렉션이나 배열을 반환하라

- 컬렉션이 빈 경우 null을 반환하면 반환 값에 대해 null여부를 체크하는 방어로직을 넣어야 한다. → 방어로직 빼먹으면 오류 발생

## 빈 컬렉션을 반환하자.

- 빈 컬렉션과 배열은 굳이 새로 할당하지 않아도 반환할 수 있다.
- 가능성이 작지만, 사용 패턴에 따라 빈 컬렉션 할당이 성능을 떨어 뜨리는 경우 → **매번 똑같은 빈 '불변' 컬렉션을 반환하면 된다.**

```jsx
public List<Cheese> getCheeses(){
	return cheeseInStock.isEmpty() ? Collections.emptyList()
					: new ArrayList<>(cheesesInStock);
}
```

- 집합이면 Collections.emptySet, 맵이면 Collections.emptyMap 을 사용하면 된다. → 단, 최적화 할 때만 사용하자.

## 길이가 0인 배열을 반환하자.

- 단순히 정확한 길이의 배열을 반환하면 된다. → 그 길이가 0일 수 도 있을 뿐이다.
1. 길이가 0일 수도 있는 배열을 반환하는 방법 

    ```jsx
    public Cheese[] getCheeses(){
    	return cheeseInStock.toArray(new Cheese[0]);
    }
    ```

2. 1번 방식의 성능저하가 우려되면 길이 0짜리 배열을 미리 선언해두고 반환한다. (길이 0인 배열은 모두 불변)

    ```jsx
    private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];
    public Cheese[] getCheese(){
    	return cheeseInStock.toArray(EMPTY_CHEESE_ARRAY);
    }
    ```

    → 단순히 성능개선 목적이면 toArray에 넘기는 배열을 미리 할당하는건 비추 → 오히려 성능 저하 

    ```jsx
    return cheeseInStock.toArray(new Cheese[cheesesInStock.size()]);
    ```

# 아이템55. 옵셔널 반환은 신중히 하라

- 자바8 이전 → 메서드가 특정 조건에세 값을 반환할 수 없을 때
    1. 예외를 던진다.

        → 진짜 예외적 상황에서만 사용해야 하며 예외를 생성할 때 스택 추적 전체 캡처 비용이 든다.

    2. null을 반환한다.

        → 별도의 null처리 코드를 작성하지 않으면 엉뚱한데서 NullPointerException 발생할 수 있다.

- 자바8 이후 → Optional<T> : null이 아닌 T타입 참조를 하나 담거나, 혹은 아무것도 담지 않는다.

## Optional<T>

: 원소를 최대 1개 가질 수 있는 '불변' 컬렉션

보통은 T를 반환해야 하지만 특정 조건에서는 아무것도 반환하지 않아야 할 때 T대신 Optional<T>를 반환하도록 선언하면 된다.

- 빈 옵셔널은 Optional.empty()
- 값이 든 옵셔널은 Optional.of(value)로 생성한다.

    → Optional.of(value)에 null넣응면 NPE 던진다.

    옵셔널을 반환하는 메서드에서는 절대 null을 반환하지 말자.

    ```jsx
    public static <E extends Comparable<E>> Optional<E> max(Collection<E> c){
    	if(c.isEmpty()){ 
    		//throw new IllegalArgumentException("빈컬렉션");
    		return Optional.empty(); //예외 대신
    	}
    	E result = null;
    	for(E e:c)
    		if(result == null || e.compareTo(result)>0)
    			result = Objects.requireNonNull(e);
    	return Optional.of(result);
    }
    ```

## Optional 반환을 활용 방법

- 옵셔널은 검사 예외와 취지가 비슷하다.

    → 반환 값이 없을 수도 있음을 API사용자에게 명확히 알려준다.

- 비검사 예외를 던지거나 null을 반환하면 오류가 발생한다.

    → 검사예외를 던지면 클라이언트에서 반드시 이에 대처하는 코드를 작성해야한다.

- 메서드가 옵셔널을 반환한다면 클라이언트는 값을 받지 못했을 때를 처리하는 코드를 작성해야 한다.
    1. 기본 값 설정 

        ```jsx
        String lastWordInLexicon = max(words).orElse("단어 없음..");
        ```

        - 기본 값 설정 비용이 크다면 Supplier<T>를 인수로 받는 orElseGet을 사용하면, 값이 처음 필요할때 Supplier<T>를 사용해 생성하므로 초기 설정비용을 낮출 수 있다.
    2. 상황에 맞는 예외 던지기

        ```jsx
        Toy myToy = max(toys).orElseThrow(TemperTantrumExceprion::new);
        ```

    3. 옵셔널에 항상 값이 채워져 있다면 곧바로 값을 꺼내 사용한다.

        ```jsx
        Element lastNobleGas = max(Elements.NOBLE_GASES).get();
        ```

    ## isPresent 메서드 활용

    : 안전밸브 역할의 메서드 

    - 옵셔널이 채워져 있으면 true, 비어있으면 false를 반환한다.

    ## 주의 사항

    - 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안 된다.

        → Optional<List<T>>를 반환하기 보다 List<T>를 반환하는게 좋다.

        빈 컨테이너를 그대로 반환하면 클라이언트에 옵셔널 처리 코드를 넣지 않아도 된다.

    - 옵셔널을 맵의 값으로 사용하면 절대 안 된다.

        → 키가 없다는 사실을 나타내는 방법이 두가지가 된다.

        1. 키 자체가 없는 경우
        2. 키는 있지만 속이 빈 옵셔널인 경우
    - 옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는게 적절한 상황은 거의 없다.

    ## 메서드 반환 타입을 T대신 Optional<T> 선택하는 경우

    **결과가 없을수도 있으며, 클라이언트가 이 상황을 특별하게 처리해야하는 경우**

    → 초기화해야하는 객체고, 값을 꺼내려면 메서드 호출해야해서 성능이 중요한 경우 맞지 않을 수 있다.

    - 박싱된 기본 타입을 담는 옵셔널은 기본 타입 자체보다 무거울 수 밖에 없다.

        → 대안 : OptionalInt, OptionalLong, OptionalDouble 을 사용한다.

    - 아이템2의 NutritionFacts 클래스의 인스턴스의 필드 중 상당수가 필수가 아닌 경우 선택적 필드의 getter메서드가 옵셔널을 반환하게 해주면 좋다.

# 아이템56. 공개된 API 요소에는 항상 문서화 주석을 작성하라

## 문서화 주석 작성시 고려할 점

- **공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다.**
- 직렬화할 수 있는 클래스라면 직렬화 형태에 관해서도 적어야 한다.
- 기본 생성자에는 문서화 주석을 달 방법이 없기 때문에 **공개 클래스는 절대 기본 생성자를 사용하면 안 된다.**
- 유지보수를 고려한다면 대다수의 공개되지 않은 선언에도 문서화 주석을 달아야 좋다.
- 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.

    → how가 아니라 what을 기술해야 한다.

- 문서화 주석에는 클라이언트가 해당 메서드를 호출하기 위한 전제조건을 모두 나열해야 한다.

    → @thows 태그로 비검사 예외를 선언하여 암시적으로 기술한다.

    → @param 태그를 이용해 그 조건에 영향받는 매개변수에 기술할 수 있다.

- 메서드 수행 후에 만족해야 하는 사후조건도 모두 나열해야 한다.
- 부작용도 문서화 해야한다. (시스템 상태에 어떠한 변화를 가져오는 것 ex. 백그라운드 스레드 시작 메서드)
- API설명에 <,>,& 등의 html메타문자를 포함 하는 방법 : {@literal} 태그로 감싼다.
- {@code} : 태그로 감싼 내용을 코드용 폰트로 렌더링 하고, 감싼 내용에 포함된 html요소 무시한다.
- 한 클래스(혹은 인터페이스) 안에서 요약설명이 똑같은 멤버(혹은 생성자)가 둘 이상이면 안 된다.
- 요약설명에서 마침표(.), 공백, 다음문장의 시작(소문자가 아닌 문자)는 요약설명의 끝을 나타내니 사용에 주의해야 한다. → 마침표를 써야한다면 {@literal} 태그 활용
- 자바10 부터는 @summary 태그 활용
- 자바9 부터 자바독이 생성한 html문서에 검색(색인) 기능 추가 {@index} 태그 사용해서 색인화 가능 ex) {@index 구연}
- **제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다.**
- 열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.
- 애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다.
- 패키지를 설명하는 문서화 주석은 package-info.java파일에 작성한다.

    → 이 파일은 패키지 선언을 반드시 포함해야 한다.

    → 패키지 선언 관련 애너테이션을 추가로 포함할 수 있다.

- 자바9 부터 지원하는 모듈시스템을 사용한다면 module-info.java파일에 작성한다.
- **클래스 혹은 정적 메서드가 스레드 안전여부과 관련없이 스레드 안전 수준을 반드시 API설명에 포함해야 한다.**
- 자바독은 메서드 주석을 상속시킬 수 있다.

    → 문서화 주석이 없는 API요소를 발견하면 자바독이 가장 가까운 문서화 주석을 찾아 준다.

    → {@inheritDoc} 태그를 사용해 상위 타입의 문서화 주석 일부를 상속할 수 있다.  

## 메서드의 계약을 완벽히 기술하는 방법

1. 모든 매개변수에 @param 태그
2. 반환 타입이  void가 아니라면 @return 태그

    → @return 태그의 설명이 메서드 설명과 같을 때 생략 가능

3. 발생할 가능성이 있는 모든 예외에 @throws태그
4. @param, @return 태그의 설명은 해당 매개변수가 뜻하는 값이나 반환값을 설명하는 명사구를 쓴다.
5. 자기사용패턴 @implSpec 태그로 남겨 다른 프로그래머들이 올바로 재정의하도록 알려줘야 한다.

    → 해당 메서드와 하위 클래스 사이의 계약을 설명하며, 하위 클래스들이 그 메서드를 상속하거나 super키워드를 이용해 호출할 때 그 메서드가 어떻게 동작하는지 알려주는 태그

    자바독 명령줄에서 아래처러 스위치 켜주지 않으면 @implSpec태그 무시한다.

    ```jsx
    -tag "impleSpec:a:Implementation Requirements:"
    ```