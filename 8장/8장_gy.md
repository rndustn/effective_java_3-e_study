# 8장. 메서드

- [ ]  메서드 설계시 주의할 점 살펴보기
- [ ]  매개변수와 반환값 처리 방법
- [ ]  메서드 시그니처 설계 방법
- [ ]  문서화 방법

# 아이템49. 매개변수가 유효한지 검사하라

- 매개변수 제약은 반드시 문서화해야하며 메서드 몸체가 시작되기 전에 검사해야 한다.
- 매개변수 검사에 실패하면 실패원자성(failure atomicity)을 어기는 결과를 낳을 수 있다.
- public 과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.

    (@throws 자바독 태그 사용)

- 매개변수의 제약을 문서화 할 때 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.
- 자바7에 추가된 java.util.Objects.requireNonNull 메서드
    - 더이상  null 검사를 수동으로 하지 않아도 된다.
    - 원하는 예외 메시지 지정 가능
    - 입력을 그대로 반환하므로 값을 사용하는 동시에  null검사를 수행할 수 있다.

    ```java
    this.strategy = Objects.requireNonNull(strategy, "전략");
    ```

- 자바9에서는 Objects에 범위 검사 기능이 추가되었다.
    - checkFromIndexSize, checkFromToIndex, checkIndex
    - null검사 메서드 만큼 유연하지 않다.
    - 예외 메시지 지정 불가
    - 리스트와 배열 전용
    - 닫힌 범위(양 끝단 값을 포함하는)는 다루지 못한다.
- public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다.

    ```java
    private static void sort(long a[], int offset, int length){
    	assert a!= null;
    	assert offset >= 0 && offset <= a.length;
    	assert length >= 0 && length <= a.length - offset;
    	...
    }
    ```

    - 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다.
    - 실패하면 AssertionError를 던진다.
    - 런타임에 아무런 효과도, 성능저하도 없다.
- 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.
    - ex) 배열의 list를 반환하는 메서드 → null 검사를 생략하면 반환된 리스트를 클라이언트가 사용할때가 되서야 예외를 발생시켜 list를 어디서 가져왔는지 추척하기 어렵다.
    - 위 사항의 특수한 사례 : 생성자 → 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.
- 메서드 몸체 실행 전에 유효성을 검사해야한다는 규칙의 예외사항
    - 유효성 검사 비용이 지나치게 높거나 실용적이지 않은 경우
    - 계산과정에서 암묵적으로 검사가 수행되는 경우
- 메서드는 최대한 범용적으로 설계해야 하기때문에 매개변수 제약은 적을 수록 좋기때문에 필요한 경우에만 제약을 두어야 한다.

# 아이템50. 적시에 방어적 복사본을 만들라

## 불변식을 깨뜨리지 않도록 방어적으로 프로그래밍 해야한다.

불변식을 지키지 못한 기간 표현 클래스 예시

```java
public final class Period{
	private final Date start;
	private final Date end;
	public Period(Date start, Date end){
		if(start.comparTo(end) > 0){
			throw new IllegalArgumentException();
		}
		this.start = start;
		this.end = end;
	}
	public Date start(){ return start; }
	public Date end(){ return end; }
	...
}
```

- Date가 가변이기 때문에 아래와 같이 공격이 가능하다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p의 내부 수정 가능
```

- java8 이후로는 Date 대신 불변인 Instant를 사용하거나, LocalDateTime, ZonedDateTime을 사용한다.
- Date는 더 이상 사용하지 않도록 한다.

## 외부공격으로부터 Period 인스턴스 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.

Period 인스턴스 안에서는 원본이 아닌 복사본을 사용해야 한다.

```java
public Period(Date start, Date end){
	this.start = new Date(start.getTime());
	this.end = new Date(end.getTime());
	if(this.start.comparTo(this.end) > 0){
		throw new IllegalArgumentException();
	}
}
```

- **매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사하는 순서로 해야한다.**

    → 멀티 스레드 환경에서는 원본 객체의 유효성을 검사한 후 복사본을 만드는 찰나의 순간에도 다른 스레드가 원본을 수정할 위험이 있기 때문이다.

- 방어적 복사에 Date의 clone메서드를 사용하지 않는다.

    → Date는 final이 아니므로 clone이 Date가 정의한 게 아닐 수 있다. 즉, clone이 악의를 가진 하위 클래스의 인스턴스를 반환할 수 있다.

- **매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.**
- Period는 접근자 메서드가 내부의 가변 정보를 직접 드러내기 때문에 아직 공격이 유효하다.

    → 접근자가 가변 필드의 방어적 복사본을 반환하도록 수정하면 된다.

    ```java
    public Date start(){ return new Date(start.getTime());}
    public Date end(){ return new Date(end.getTime());}
    ```

    생성자와 달리 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다.

    → Period가 가진 Date객체는 java.util.Date임이 확실하기 때문이다.

    **그래도 인스턴스를 복사하는 데는 생성자나 정적 팩터리를 쓰는게 좋다.**

## 방어적 복사가 필요한 경우

1. 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지 따져봐야 한다. → 확신할 수 없다면 복사본 만들어 저장해야 한다.
2. 길이가 1 이상인 배열은 무조건 가변이다. → 내부에서 사용하는 배열을 클라이언트에 반화할 때 항상 방어적 복사를 수행해야 한다.

## ✏️핵심정리

- 되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다.
- 호출자가 컴포넌트 내부를 수정하지 않는다 확신하면 방어적 복사 생략 가능하다 → 방어적복사는 성능저하가 따르고, 또 항상 사용할 수 있지도 않다.(같은 패키지에 속하는 경우)
- 방어적 복사를 생략해도 되는 상황은 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때, 혹은 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때로 한정해야 한다.

# 아이템51. 메서드 시그니처를 신중히 설계하라.

## 1. 메서드 이름을 신중이 짓자.

- 표준 명명 규칙을 따라야 한다.
- 이해하기 쉽고, 일관성 있게 지어야 한다.

## 2. 편의 메서드를 너무 많이 만들기 말자.

- 메서드가 너무 많으면 익히고, 사용, 문서화, 테스트, 유지보수가 어렵다.
- 클래스나 인터페이스는 자신의 각 기능을 완벽히 수행하는 메서드로 제공해야 한다.
- 아주 자주 쓰일 경우에만 별도의 약칭 메서드를 둔다.

## 3. 매개변수 목록은 짧게 유지하자.

- 4개 이하가 좋다. → 많으면 기억하기 어렵다.
- 같은 타입의 매개변수 여러 개가 연달아 나오는 경우 특히 해롭다. → 실수로 순서를 바꾸면 오작동한다.
- 매개변수 목록을 짧게 줄여주는 기술 세가지
    1. 원래 매개변수 목록의 부분집합을 받는 여러 메서드로 쪼갠다.

        ex) java.util.List → 지정 범위의 부분리스트에서 주어진 원소의 인덱스 찾는 경우 : subList, indexOf

    2. 매개변수 여러 개를 묶어주는 도우미 클래스를 만든다.
        - 도우미 클래스는 정적 멤버 클래스로 둔다.
        - 잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있을 경우 추천

            ex) 카드게임을 클래스로 만들 때 항상 같은 순서로 전달되는 숫자와 무늬 매개변수를 묶는 도우미

    3. 1,2번 혼합한 것으로 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용한다.
        - 매개변수가 많을 때, 특히 그중 일부는 생략해도 괜찮을 때 도움된다.

        수행 절차

        1. 모든 매개변수를 하나로 추상화한 객체를 정의하고, 클라이언트에서 이 객체의 세터메서드를 호출해 필요한 값을 설정하게 한다.
        2. 이때 각 세터 메서드는 매개변수 하나 혹은 서로 연관된 몇 개만 설정하게 한다.
        3. 클라이언트는 먼저 필요한 매개변수를 다 설정한다.
        4. execute 메서드를 호출해 앞서 설정한 매개변수들의 유효성을 검사한다.
        5. 설정이 완료된 객체를 넘겨 원하는 계산을 수행한다.

## 4. 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다.

- 매개변수로 적합한 인터페이스가 있다면(이를 구현한 클래스가 아닌) 그 인터페이스를 직접 사용하자.

    ex) 메서드에 HashMap을 넘길 일은 전혀 없다. 대신 Map을 사용한다.

    → HashMap뿐만 아니라 TreeMap, ConcurrentHashMap, TreeMap의 부분맵 등 어떤 Map 구현체도 인수로 건넬 수 있다.

- 아직 존재하지 않는 Map 구현체도 인수로 넘길 수 있다.
- 인터페이스 대신 클래스를 사용하는 것은 특정 구현체만 인수로 넘기도록 제한하는 것이다.

    → 입력 데이터의 타입이 다르면 특정 구현체로 변경해야 한다.

## 5. boolean보다는 원소 2개짜리 열거 타입이 낫다.

- 코드를 읽고 쓰기 더 쉬워진다.
- 나중에 선택지 추가가 쉽다.

# 아이템52. 다중정의는 신중히 사용하라.

## 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다.

- 메서드를 다중정의하면 어느 메서드를 호출할지가 매개변수의 컴파일타임 타입을 기준으로 정해진다.
- 메서드를 재정의하면 해당 객체의 런타임 타입이 어떤 메서드를 호출할지의 기준이 된다.
- 다중정의 문제는 메서드를 하나로 합치고 instanceof로 명시적 검사하면 해결된다.

    ```java
    public static String classify(Collection<?>c){
    	return c instanceof Set ? "집합":
    				 c instanceof List ? "리스트" : "그 외";
    }
    ```

## 다중정의시 주의할 점

1. 다중정의가 혼동을 일으키는 상황을 피해야 한다.
2. 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.

    가변인수를 사용하는 메서드라면 다중정의를 아예 사용하지 말자.

3. 다중정의하는 대신 메서드 이름을 다르게 지어준다.

    ex) ObjectOutputStream클래스의 write메서드

    - 다중정의 대신 타입별로 다른 이름의 메서드 생성
    - writeBoolean, writeInt, writeLong 등

## 생성자 - 이름을 다르게 지을 수 없다.

- 생성자는 이름을 다르게 지을 수 없어 두 번째 생성자부터는 무조건 다중정의가 된다.
- 정적 팩터리라는 대안을 활용한다.
- 생성자는 재정의 불가

### 여러 생성자가 같은 수의 매개변수를 받아야하는 경우 안전 대책

매개변수 중 **하나 이상이 타입의 값을 서로 어느쪽으로든 형변환 할 수 없다**는 조건만 충족하면 매개변수들의 런타임 타입만으로 호출되는 메서드가 결정된다.

ex) ArrayList 클래스에 있는 int를 받는 생성자와 Collection을 받는 생성자 둘은 어느것이 호출될 지 헷갈리지 않는다.

## 제네릭과 오토박싱이 추가된 후 List 인터페이스 사용시 주의할 점

0~5까지 들어있는 set과 list를 비교하면

set.remove()의 시그니처는 remove(Object) 여서 remove(3)하면 3이라는 값이 제거된다.

list.remove()는 remove(Object)와 remove(int index)가 다중정의되어 있어 index가 3인 2값이 제거된다.

해결 : list.remove((Integer)i) 혹은 remove(Integer.valueOf(i)) 로 Object 타입으로 변환해야 한다.

## 람다와 메서드 참조가 추가된 후 주의할 점

**메서드를 다중정의할 때, 서로 다른 함수형 인터페이스도 같은 위치의 인수로 받아서는 안 된다.**

```java
// 1번. Thread의 생성자 호출
new Thread(System.out::println).start();
// 2번. ExecutorService의 submit 메서드 호출
ExecutorService exec = Executors.newCachedThreadPool();
exec.submit(System.out::println);
```

- 2번만 컴파일 오류난다.
- 원인: submit 다중정의 메서드 중에는 Callable<T>를 받는 메서드도 있다.
- 참조된 메서드(println)와 호출한 메서드(submit) 양쪽 다 다중정의되어, 다중정의 해소 알고리즘이 제대로 작동하지 않는다.

## Forword

어떤 다중정의 메서드가 호출될지 몰라도 기능이 똑같다면 신경 쓸 필요 없다.

이런 경우 더 특수한 메서드에서 더 일반적인 메서드로 포워드해주어 동일한 일을 하도록 보장해준다.

```java
public boolean contentEquals(StringBuffer sb){
	return contentEquals((CharSequence)sb);
}
```

## ✏️핵심정리

- 매개변수 수가 같을 때는 오버로딩을 피해야 한다.
- 생성자와 같이 오버로딩해야하는 경우엔 헷갈릴 만한 매개변수는 형변환하여 정확한 오버로딩메서드가 선택되도록 한다.
- 위 방법이 불가한, 기존 클래스를 수정해 새로운 인터페이스를 구현해야할 때는 같은 객체를 입력받는 오버로딩 메서드들이 모두 동일하게 동작하도록 만들어야 한다.