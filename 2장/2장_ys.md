# 2장. 객체 생성과 파괴

1. 객체를 만들어야 할 때 만들지 말아야 할 때를 구분하는 법.
2. 올바른 객체 생성 방법과 불필요한 생성을 피하는 방법.
3. 제때 파괴됨을 보장하고 파괴 전에 수행해야 할 정리 작업을 관리하는 요령

---

[https://www.notion.so/2-83a9e156bf4d41d2bc6c04123f187160](https://www.notion.so/2-83a9e156bf4d41d2bc6c04123f187160)

# 아이템1. 생성자 대신 정적 팩터리 메서드를 고려하라.

클래스는 생성자와 별도로 **정적 팩터리 메서드(static factory method)**를 제공할 수 있다.

: 클래스의 인스턴스를 반환하는 단순한 정적 메서드 

ex)

```java
public static Boolean valueOf(boolean b){
	return b ? Boolean.TRUE : Boolean.FALSE;
}
```

### 정적 메소드가 생성자보다 좋은 장점 다섯가지

1. 이름을 가질 수 있다. = 반환될 객체의 특정을 쉽게 묘사할 수 있다.
2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. = 플라이웨이트 패턴과 비슷한 기법

플라이웨이트 패턴은, 객체의 내부에서 참조하는 객체를 직접 만드는 것이 아니라, 없다면 만들고, 
만들어져 있다면 객체를 공유하는 식으로 객체를 구성하는 방법

 3.  반환 타입의 하위 타입 객체를 반환할 수 있는 능력 제공 = 엄청난 유연성 = 자바 8부터는 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸다.

 4.  입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

      = 반환타입의 하위 타입이만 하면 어떤 클래스의 객체를 반환하든 상관이 없다.

 5.   정적 패터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

      = 서비스 제공자 프레임워크를 만드는 근간이 된다.

**서비스 제공자 프레임워크**

: 제공자들이 구성하는 서비스 구현체다, 그리고 이 구현체들을 클라이언트에게 제공하는 역할을 프레임워크가 통제하여 클라이언트를 구현체로부터 분리해준다. (클라이언트는 제공자들을 몰라도 이용할 수 있다.)

ex) JDBD(Java Database Connectivity) 의 제공자 : mysql, oracle

**서비스 제공자 프레임워크의 3가지 핵심 컴포넌트** 

1. 구현체의 동작을 정의하는 **서비스 인터페이스(service interface)** 
2. 제공자가 구현체를 등록할 때 사용하는 **제공자 등록 api(provider registration API)**
3. 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 **서비스 접근 api (service access API)**

+ 종종 **서비스 제공자 인터페이스(service provider interface)**라는 네번째 컴포넌트가 쓰이는데 이 컴포넌트는 서비스 인스턴스를 생성하는 팩터리 객체를 설명해준다.

```
Ex. < JDBC >
서비스 인터페이스 : Connection
제공자 등록 API : DriverManager.registerDrive()
서비스 접근 API : DriverManager.getConnection()
서비스 제공자 인터페이스 : Driver
```

### 단점 다섯가지

1. 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다. = 컬렉션 프레임워크의 유틸리티 구현클래스들을 상속할 수 없다.
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.  = 문서에 설명이 잘없다.

[정적팩터리 메서드에 흔히 사용하는 명명방식들 ](https://www.notion.so/170e56bed5194eed844da832c79cc866)

# 아이템2. 생성자에 매개변수가 많다면 빌더를 고려하라.