# 10장. 예외

# 아이템69. 예외는 진짜 예외 상황에만 사용하라.

- 예외를 잘못 사용한 예

    ```java
    try{
    	int i = 0;
    	while(true)
    		range[i++].climb();
    }catch(ArrayIndexOutOfBoundsException e){
    }
    ```

- 표준 관용구

    ```java
    for(Mountain m : range)
    	m.climb();
    ```

- 예외를 써서 루프를 종료한 이유 → 잘못된 추론을 근거로 성능을 높이려 함 : JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사하는데, 일반적인 반복문도 배열 경계에 도달하면 종료한다. → 이 검사를 반복문에도 명시하면 같은 일이 중복되므로 하나를 생략한 것이다.
- 잘못된 이유
    1. 예외는 예외 상황에 쓸 용도로 설계되어 JVM구현자는 최적화에 별로 신경쓰지 않았을 가능성이 크다.
    2. 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
    3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복검사를 수행하지 않느다. JVM이 알아서 최적화해 없애준다.
- 예외를 사용한 쪽이 표준 관용구보다 훨씬 느리다.
- 예외는 오직 예외 상황에서만 써야 한다. → 일상적인 제어 흐름용으로 쓰여선 안 된다.

    ex) 반복문의 몸체에서 호출한 메서드가 내부에서 관련 없는 배열을 사용하다가 ArrayIndexOutOfBoundsException을 일으켰다면 표준 관용구였다면 해당 스레드를 즉각 종료시킬것이다. 반면 예외를 사용한 반복문은 버그 때문에 발생한 예외를 정상적인 반복문 종료 상황으로 오해하고 넘어간다.

- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
- 특정 상태에서만 호출할 수 있는  '상태 의존적' 메서드를 제공하는 클래스는 '상태 검사' 메서드도 제공해야 한다. ex) Iterator 인터페이스 (상태 의존적 메서드 next, 상태 검사 메서드 hasNext)

    ```java
    for(Iterator<Foo> i = collection.iterator(); i.hasNext();){
    	Foo foo = i.next();
    	...
    }
    ```

- 상태 검사 메서드 대신 사용 → 올바르지 않은 상태일 때 빈 옵셔널 또는 null 반환

## 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
3. 그 외 다른 경우엔 상태 검사 메서드 방식이 가독성이 더 좋고 잘못 사용했을 때 발견하기 쉽다.

    상태 검사 메서드 호출을 누락하면 상태 의존적 메서드가 예외를 던진다. 반면, 특정 값은 검사하지않고 지나친다.(옵셔널은 해당없는 문제)

# 아이템70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.

자바는 문제 상황을 알리는 타입으로 검사 예외, 비검사 예외 (런타임 예외, 에러) 세 가지를 제공한다.

## 검사 예외 - 호출하는 쪽에서 복구하리라 여겨지는 상황에 사용하라.

- 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로  전파하도록 강제하게 된다.
- API 설계자는 API 사용자에게 검사예외를 던져주어 그 상황에서 회복해내라고 요구한다.

## 비검사 예외 (런타임 예외, 에러)

- 프로그램에서 잡을 필요가 없거나 복구가 불가능하거나 더 실행해봐야 득보다 실이 많은 경우 사용한다.

### 1. 런타임 예외 - 프로그래밍 오류를 나타낼 때 사용하라.

- 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다. - API 명세에 기록된 제약을 지키지 못함
- 복구 가능여부를 판단하기 어렵다면 비검사 예외를 선택하는 편이 낫다.

### 2. 에러 - JVM이 자원부족, 불변식 깨짐 등 더이상 수행 할 수 없는 상황에 사용하라.

- 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.
- Error 클래스를 상속하지 말아야하며, throw문으로 직접 던지는 일도 없어야 한다. (AssertionError는 예외)

참고) 검사예외도 아니고 런타임 예외도 아닌 throwable은 절대로 사용하지 말자.

# 아이템71. 필요 없는 검사 예외 사용은 피하라.

## 검사예외 사용을 고려해야 하는 이유

- 검사 예외를 던질 수 있다고 메서드를 선언하면 호출하는 코드에서 catch 블록을 두어 예외를 처리하거나 더 바깥으로 던져 문제를 전파해야 한다.
- 검사예외를 던지는 메서드는 스트림 안에서 직접사용 할 수 없어 자바 8부터 부담이 커졌다.
- 메서드가 단 하나의 검사 예외만 던질 때 부담이 더 크다. 이미 다른 검사 예외도 던지는 상황에서 또 다른 검사 예외를 추가하는 경우엔 catch 문 하나 추가하면 된다. 하지만 단 하나라면 그 예외 때문에 try 블록을 추가하고 스트림에서 직접 사용하지 못하게 된다.

API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미있는 조치를 취할수 있는 경우가 아니라면 비검사 예외를 사용하는게 좋다.

## 검사 예외를 회피하는 가장 쉬운 방법

- 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다. → 검사 예외를 던지는 대신 빈 옵셔널을 반환한다.

    단점: 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.

    예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가정보를 얻을 수 있다.

- 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다.

    첫 번째 메서드는 예외가 던져질지 여부를 boolean 값으로 반환한다.

    - 검사 예외를 던지는 메서드 - 리팩터링 전

        ```java
        try{
        	obj.action(args);
        }catch(TheCheckedException e){
        	...// 예외사항에 대처
        }
        ```

    - 상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩터링 후

        ```java
        if(obj.actionPermitted(args)){
        	obj.action(args);
        }else{
        	...// 예외사항에 대처
        }
        ```

    - 프로그래머가 이 메서드가 성공하리란걸 알거나, 실패 시 스레드를 중단하길 원한다면  obj.action(args); 한 줄로 작성해도 된다.
    - actionPermitted는 상태 검사 메서드에 해당하므로 외부 동기화 없이 여러 스레드가 동시 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 actionPermitted와 action 호출 사이에 객체의 상태가 변할 수 있다.
    - actionPermitted와 action 메서드의 작업 일부를 중복 수행한다면 성능에서 손해이다.

    ## ✏️핵심정리

    - 검사 예외는 프로그램의 안정성을 높여주지만, 남용하면 쓰기 어려운API를 낳는다.
    - 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던진다.
    - 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.
    - 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.

# 아이템72. 표준 예외를 사용하라.

## 표준 예외 재사용의 이점

- 익히고 사용하기 쉬워진다.
- 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다.

[가장 많이 사용되는 예외](https://www.notion.so/427446702240403fa5f9ea37d5c85c42)

Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.

→ 이 예외들은 다른 예외들의 상위 클래스로, 여러 성격의 예외들을 포괄하는 클래스이므로 안정적으로 사용할 수 없다.

## 표준 예외 재사용시 고려할 점

- API 문서를 참고해 그 예외가 어떤 사황에 던져지는지 확인한다.
- 예외의 이름뿐 아니라 예외가 던져지는 맥락도 부합할 때만 재사용한다.
- 더 많은 정보를 제공하고자 하면 표준 예외를 확장해도 좋다.
- 단, 예외는 직렬활할 수 있다는 사실을 기억하자. (직렬화에는 많은 부담이 따른다.)
- 인수 값이 무엇이었든 어차피 실패했을 거라면 IllegalStateException을 , 그렇지 않으면 IllegalArgumentException을 던지자.

# 아이템73. 추상화 수준에 맞는 예외를 던지라.