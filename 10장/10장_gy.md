# 10장. 예외

# 아이템69. 예외는 진짜 예외 상황에만 사용하라.

- 예외를 잘못 사용한 예

    ```java
    try{
    	int i = 0;
    	while(true)
    		range[i++].climb();
    }catch(ArrayIndexOutOfBoundsException e){
    }
    ```

- 표준 관용구

    ```java
    for(Mountain m : range)
    	m.climb();
    ```

- 예외를 써서 루프를 종료한 이유 → 잘못된 추론을 근거로 성능을 높이려 함 : JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사하는데, 일반적인 반복문도 배열 경계에 도달하면 종료한다. → 이 검사를 반복문에도 명시하면 같은 일이 중복되므로 하나를 생략한 것이다.
- 잘못된 이유
    1. 예외는 예외 상황에 쓸 용도로 설계되어 JVM구현자는 최적화에 별로 신경쓰지 않았을 가능성이 크다.
    2. 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
    3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복검사를 수행하지 않느다. JVM이 알아서 최적화해 없애준다.
- 예외를 사용한 쪽이 표준 관용구보다 훨씬 느리다.
- 예외는 오직 예외 상황에서만 써야 한다. → 일상적인 제어 흐름용으로 쓰여선 안 된다.

    ex) 반복문의 몸체에서 호출한 메서드가 내부에서 관련 없는 배열을 사용하다가 ArrayIndexOutOfBoundsException을 일으켰다면 표준 관용구였다면 해당 스레드를 즉각 종료시킬것이다. 반면 예외를 사용한 반복문은 버그 때문에 발생한 예외를 정상적인 반복문 종료 상황으로 오해하고 넘어간다.

- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
- 특정 상태에서만 호출할 수 있는  '상태 의존적' 메서드를 제공하는 클래스는 '상태 검사' 메서드도 제공해야 한다. ex) Iterator 인터페이스 (상태 의존적 메서드 next, 상태 검사 메서드 hasNext)

    ```java
    for(Iterator<Foo> i = collection.iterator(); i.hasNext();){
    	Foo foo = i.next();
    	...
    }
    ```

- 상태 검사 메서드 대신 사용 → 올바르지 않은 상태일 때 빈 옵셔널 또는 null 반환

## 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
3. 그 외 다른 경우엔 상태 검사 메서드 방식이 가독성이 더 좋고 잘못 사용했을 때 발견하기 쉽다.

    상태 검사 메서드 호출을 누락하면 상태 의존적 메서드가 예외를 던진다. 반면, 특정 값은 검사하지않고 지나친다.(옵셔널은 해당없는 문제)

# 아이템70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.

자바는 문제 상황을 알리는 타입으로 검사 예외, 비검사 예외 (런타임 예외, 에러) 세 가지를 제공한다.

## 검사 예외 - 호출하는 쪽에서 복구하리라 여겨지는 상황에 사용하라.

- 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로  전파하도록 강제하게 된다.
- API 설계자는 API 사용자에게 검사예외를 던져주어 그 상황에서 회복해내라고 요구한다.

## 비검사 예외 (런타임 예외, 에러)

- 프로그램에서 잡을 필요가 없거나 복구가 불가능하거나 더 실행해봐야 득보다 실이 많은 경우 사용한다.

### 1. 런타임 예외 - 프로그래밍 오류를 나타낼 때 사용하라.

- 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다. - API 명세에 기록된 제약을 지키지 못함
- 복구 가능여부를 판단하기 어렵다면 비검사 예외를 선택하는 편이 낫다.

### 2. 에러 - JVM이 자원부족, 불변식 깨짐 등 더이상 수행 할 수 없는 상황에 사용하라.

- 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.
- Error 클래스를 상속하지 말아야하며, throw문으로 직접 던지는 일도 없어야 한다. (AssertionError는 예외)

참고) 검사예외도 아니고 런타임 예외도 아닌 throwable은 절대로 사용하지 말자.

# 아이템71. 필요 없는 검사 예외 사용은 피하라.

## 검사예외 사용을 고려해야 하는 이유

- 검사 예외를 던질 수 있다고 메서드를 선언하면 호출하는 코드에서 catch 블록을 두어 예외를 처리하거나 더 바깥으로 던져 문제를 전파해야 한다.
- 검사예외를 던지는 메서드는 스트림 안에서 직접사용 할 수 없어 자바 8부터 부담이 커졌다.
- 메서드가 단 하나의 검사 예외만 던질 때 부담이 더 크다. 이미 다른 검사 예외도 던지는 상황에서 또 다른 검사 예외를 추가하는 경우엔 catch 문 하나 추가하면 된다. 하지만 단 하나라면 그 예외 때문에 try 블록을 추가하고 스트림에서 직접 사용하지 못하게 된다.

API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미있는 조치를 취할수 있는 경우가 아니라면 비검사 예외를 사용하는게 좋다.

## 검사 예외를 회피하는 가장 쉬운 방법

- 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다. → 검사 예외를 던지는 대신 빈 옵셔널을 반환한다.

    단점: 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.

    예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가정보를 얻을 수 있다.

- 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다.

    첫 번째 메서드는 예외가 던져질지 여부를 boolean 값으로 반환한다.

    - 검사 예외를 던지는 메서드 - 리팩터링 전

        ```java
        try{
        	obj.action(args);
        }catch(TheCheckedException e){
        	...// 예외사항에 대처
        }
        ```

    - 상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩터링 후

        ```java
        if(obj.actionPermitted(args)){
        	obj.action(args);
        }else{
        	...// 예외사항에 대처
        }
        ```

    - 프로그래머가 이 메서드가 성공하리란걸 알거나, 실패 시 스레드를 중단하길 원한다면  obj.action(args); 한 줄로 작성해도 된다.
    - actionPermitted는 상태 검사 메서드에 해당하므로 외부 동기화 없이 여러 스레드가 동시 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 actionPermitted와 action 호출 사이에 객체의 상태가 변할 수 있다.
    - actionPermitted와 action 메서드의 작업 일부를 중복 수행한다면 성능에서 손해이다.

    ## ✏️핵심정리

    - 검사 예외는 프로그램의 안정성을 높여주지만, 남용하면 쓰기 어려운API를 낳는다.
    - 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던진다.
    - 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.
    - 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.

# 아이템72. 표준 예외를 사용하라.

## 표준 예외 재사용의 이점

- 익히고 사용하기 쉬워진다.
- 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다.

[가장 많이 사용되는 예외](https://www.notion.so/427446702240403fa5f9ea37d5c85c42)

Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.

→ 이 예외들은 다른 예외들의 상위 클래스로, 여러 성격의 예외들을 포괄하는 클래스이므로 안정적으로 사용할 수 없다.

## 표준 예외 재사용시 고려할 점

- API 문서를 참고해 그 예외가 어떤 사황에 던져지는지 확인한다.
- 예외의 이름뿐 아니라 예외가 던져지는 맥락도 부합할 때만 재사용한다.
- 더 많은 정보를 제공하고자 하면 표준 예외를 확장해도 좋다.
- 단, 예외는 직렬활할 수 있다는 사실을 기억하자. (직렬화에는 많은 부담이 따른다.)
- 인수 값이 무엇이었든 어차피 실패했을 거라면 IllegalStateException을 , 그렇지 않으면 IllegalArgumentException을 던지자.

# 아이템73. 추상화 수준에 맞는 예외를 던지라.

아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란한 경우 예외 번역을 사용한다.

## 예외 번역 : 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.

```java
try{
 ...//저수준 추상화를 이용한다.
}catch (LowerLevelException e){
	//추상화 수준에 맞게 번역한다.
	throw new HigherLevelException(...);
}
```

## 예외 연쇄 : 문제의 근본 원인(cause)인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.

- 예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면 예외연쇄를 사용하는게 좋다.
- 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본원인도 함께 알려주어 오류를 분석하기 좋다.

```java
try{
 ...//저수준 추상화를 이용한다.
}catch (LowerLevelException cause){
	//저수준 예외를 고수준 예외에 실어 보낸다.
	throw new HigherLevelException(cause);
}
```

- 예외 연쇄를 지원하는 메소드

    ```java
    Throwable getCause()
    Throwable initCause(Throwable)
    Throwable(String, Throwable)
    Throwable(Throwable)
    ```

    - Throwable 생성자에서 인수를 initCause 에 넘기고 Throwable 생성 시키고 현재 원인은 getCause 로 확인 가능 다시 원인을 설정할때는 initCause를 사용
- HigherLevelException 생성자는 (예외 연쇄용으로 설계된) 상위 클래스의 생성자에 이 'cause'를 건네주어, 최종적으로 Throwable(Throwable) 생성자까지 건네지게 한다.
- 예외 연쇄용 생성자

    ```java
    class HigherLevelException extends Exception{
    	HigherLevelException(Throwable cause){
    		super(cause);
    	}
    }
    ```

- 예외 연쇄는 문제의 원인을(getCause 메서드로) 프로그램에서 접근할 수 있게 해주며, 원인과 고수준 예외의 스택 추적 정보를 잘 통합해준다.
- 가능한 저수준 메서드가 반드시 성공하도록하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.
- 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법도 있다.

## 차선책

- 아래 계층에서 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에까지 전파하지 않고 발생한 예외는 java.util.logging 로깅 기능을 활용하여 기록한다.

# 아이템74. 메서드가 던지는 모든 예외를 문서화하라.

- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.
- 공통 상위 클래스 하나로 뭉뜽그려 선언하는 일은 삼가자.

    ex) 메서드가 Exception 이나 Throwable을 던진다고 선언하면 안 된다.

    → 메서드 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못할뿐더러, 같은 맥락에서 발생할 여지가 있는다른 예외까지 삼킬 수 있다.

    단, main 메서드는 오직 JVM만이 호출하므로 Exception을 던지도록 선언해도 된다.

- 비검사 예외(일반적인 프로그래밍 오류)도 검사 예외처럼 문서화 해두면 좋다.
- public 메서드라면 필요한 전제조건을 문서화해야 한다.
- 메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.

    ```java
    /**
     * blah blah...
     *
     * @param divisor
     * @throws ArithmeticException -> 비검사 예외는 여기서만 문서화 하고
     *     Exception may occur when divisor is zero    
     */
    public int someMethod(int divisor){ //throws ArithmeticException {
        // throws 선언에는 제외하는 것을 권장한다.
    }
    ```

    - javadoc 유틸리티에서는 메서드 선언의 throws 절에 등장하고 메서드 주석의 @throws 태그에도 명시된 검사 예외와 @throws 태그에만 명시된 비검사 예외를 시각적으로 구분한다.
- 비검사 예외가 현실적으로 모두 문서화가 안 되는 경우도 있다.

    : 클래스를 수정하면서 새로운 비검사 예외를 던지게 되어도 소스 호환성과 바이너리 호환성이 그대로 유지된다.
    ex) 외부 클래스를 사용하는 메서드가 있을 때, 그 외부 클래스가 다른 예외를 던지도록 수정된다면 아무 수정도 하지 않은 기존 메서드는 javadoc에 언급되지 않은 새로운 예외를 던진다.

- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 (각각의 메서드가 아닌) 클래스 설명에 추가하는 방법도 있다.
ex) NullPointerException

# 아이템75. 예외의 상세 메시지에 실패 관련 정보를 담으라.

- 예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 스택 추적 정보를 자동으로 출력한다.
- 스택 추적 : 예외 객체의 toString 메서드를 호출해 얻는 문자열로, 보토은 예외의 클래스 이름 뒤에 상세 메시지가 붙는 형태다.
- 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.

    → 필요한 정보를 예외 생성자에서 모두 받아서 상세 메시지까지 미리 생성해 놓는 방법도 괜찮다.

    ```java
    /**
     * IndexOutOfBoundsException을 생성한다
     * @param lowerBound 인덱스의 최솟값
     * @param upperBound 인덱스의 최댓값 + 1
     * @param index 인덱스의 실젯값
     */
    public IndexOutOfBoundsException(int lowerBound, int upperBound, int index){
        // 실패를 포착하는 상세 메시지를 생성한다.
       super(String.format("최솟값: %d , 최댓값: %d, 인덱스: %d", lowerBound, upperBound, index));
       
       // 프로그램에서 이용할 수 있도록 실패 정보를 저장해둔다.
       this.lowerBound = lowerBound;
       this.upperBound = upperBound;
       this.index = index;
    }
    ```

- 예외는 실패와 관련된 정보를 얻을 수 있는 접근자 메서드를 적절히 제공하는 것이 좋다.

    위 예시의 lowerBound, upperBound, index

- 예외가 발생한 파일 이름과 줄번호, 스택에서 호출한 다른 메서드들의 파일이름과 줄번호까지 정확히 기록되어있어야 한다.
- 예외 메시지는 가독성보다 담긴 내용이 중요하다.
- 자바9에서는 IndexOutOfBoundsException에 정수 인덱스 값을 받는 생성자가 추가 됨 (이전엔 String) 하지만, 최솟값, 최댓값은 받지 않는다.

    ```java
    public class IndexOutOfBoundsException extends RuntimeException {
        private static final long serialVersionUID = 234122996006267687L;
        public IndexOutOfBoundsException() {
            super();
        }
        public IndexOutOfBoundsException(String s) {
            super(s);
        }
        public IndexOutOfBoundsException(int index) {
            super("Index out of range: " + index);
        }
    }
    ```

- 포착한 실패 정보는 예외상황을 복구하는 데 유용할 수 있으므로 접근자 메서드는 비검사 예외보다 검사 예외에서 유용하다.

# 아이템76. 가능한 한 실패 원자적으로 만들라.

## 실패 원자적이란?

- 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.

## 메서드를 실패 원자적으로 만드는 방법

1. 불변 객체로 설계한다.
    - 불변 객체는 태생적으로 실패 원자적이다.
    - 메서드가 실패하면 새로운 객체가 만들어지지 않을 수는 있으나 기존 객체가 불안정한 상태에 빠질리 없다. → 불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않기 때문이다.
2. 가변 객체의 메서드를 실패 원자적으로 만드는 방법
    1. 작업 수행에 앞서 매개변수의 유효성을 검사하는 것이다.
    → 객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성을 대부분 걸러내는 방법이다.
    2. 실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치한다.

        → 계산 수행 전 인수의 유효성 검사

3. 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공하면 원래 객체와 교체하는 방법이다.

    → 데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식이다.

4. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법이다.

    → 주로 (디스크 기반의) 내구성을 보장해야하는 자료구조에 쓰이며, 자주 쓰이지 않는다.

## 실패 원자성 고려할 점

- 실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산의 경우 적용을 고려한다.
- 항상 달성할 수 없다.
    1. 두 스레드가 동기화 없이 같은 객체를 동시에 수정하는 경우 그 객체의 일관성이 깨진다.
    2. Error는 복구할 수 없다.

# 아이템77. 예외를 무시하지 말라.

- try - catch 문에서 catch 블록을 비워두면 예외가 존재할 이유가 없어진다.
- 예외를 무시해야 하는 상황

    ex) FileInputStream을 닫을 때 (입력 전용 스트림)
    → 파일의 상태를 변경하지 않았으니 복구할 것이 없으며, 스트림을 닫는다는 건 필요한 정보는 이미 다 읽었다는 뜻이니 남은 작업을 중단할 이유도 없다. (대신 파일 닫지 못한 부분 로그로 남기면 좋다.)

- 예외를 무시하기로 했다면 catch 블록 안에 그러게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔준다.

```java
Future<Integer> f = exec.submit(planarMap::chromaticNumber);
int numColors = 4; //기본값. 어떤 지도라도 이 값이면 충분하다.
try{
	numColors = f.get(1L, TimeUnit.SECONDS);
}catch( TimeoutException | ExecutionException ignored){
	//기본값을 사용한다(색상 수를 최소화하면 좋지만, 필수는 아니다).
}
```