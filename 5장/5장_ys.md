# 5장. 제네릭

제네릭은 자바 5부터 사용할 수 있다.

엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단하여 더 안전하고 명확한 프로그램을 만들어 준다.

- 타입안정성 확보

# 아이템 26. 로 타입은 사용하지 말라

**제네릭 타입 : 제네릭 클래스 혹은 제네릭 인터페이스** : 클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰인 것. : List<E>

제네릭 타입은 그에 딸린 로 타입도 함께 정의된다.

**로타입** : 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 때 ex) List<E>의 로타입은 List

- 제네릭타입 정보가 전부 지워진 것 처럼 동작
- 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책
- 사용하면 안된다!
- 런타임에 오류가 발생하기때문에 안정성이 떨어진다.
- 표현력도 떨어진다.

ClassCastException : 잘못된 타입의 변수가 들어갔을 때 발생.

Set<Object> : 매개변수화 타입 : 어떤 타입의 객체도 저장할 수 있다.

Set<?> : 와일드카드 타입 : 모종의 타입 객체만 저장할 수 있다.

Set : 로타입

![5%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%20af2593a9092b4a9c94dd87b41c2918e0/Untitled.png](5%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%20af2593a9092b4a9c94dd87b41c2918e0/Untitled.png)

# 아이템 27. 비검사 경고를 제거하라

제네릭을 사용하기 시작하면, 비검사형 변환 경고, 비 검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 발생한다. → 이런 경고들은 할 수 있는 한 전부 제거하라.

더 이상 경고를 제거할 수 없는데, 안전하다고 확실할 경우에는 

**@SupperessWarnings("unchecked")** 어노테이션을 달아 경고를 숨길 수 있다.

- 항상 가능한 한 좁은 범위에 적용해야한다.
- 안전하다고 확신할 경우메나 적용해야 한다.
- 경고를 무시하고 해당 어노테이션을 사용한 이유를 항상 주석으로 남겨야 한다.

# 아이템 28. 배열보다는 리스트를 사용하라

배열 : 공변이고 실체화, 런타입에 에러 발생 

제네릭 : 불공변이고 타입정보가 소거, 컴파일 타입에 에러 발생

→ 컴파일 시 에러가 발생하는 것이 훨씬 좋다

→ 둘을 섞어쓰다 오류나 경고가 난다면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자.

공변: 함께 변한다.

실제화: 런타입에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다. 

ArraysStoreException : Long 배열에 String 을 넣으려고했을 경우와 같은 상황에 발생.

아이템 29. 이왕이면 재네릭 타입으로 만들라.

새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 재네릭 타입으로 만드는 것이 더 안전하고 쓰기 편하다. : 기존 클라이언트에는 아무 영향을 주지 않으면서 새로운 사용자를 훨씬 편하게 해주는 길이다.

### 배열을 사용한 코드를 제네릭으로 만드는 방법

1. 가독성 , 현업에서 선호, 자주 사용 

```java
//배열 elements는 push(E)로 넘어온 E인스턴스만 담는다.
//따라서 타입 안전성을 보장하지만,
//이 배열의 런타임 타입은 E[]가 아닌 Object[]다!
@SupperessWarnings("unchecked") 
public Stack() {
   elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
}
```

2. 힙 오염이 걸리지 않을 수 있는 방법

```java
public E pop() {
  if(size == 0)
     throw new EmptyException();

//push에서 E타입만 허용하므로 이 형변환은 안전하다.
@SupperessWarnings("unchecked") E result = (E) elements[--size];

elements[size] = null ; //다 쓴 참조 해제
return result;
}
```

# 아이템 30. 이왕이면 제네릭 메서드로 만들라

클래스와 마찬가지로, 메서드도 제네릭으로 만들 수 있다.

제네릭메서드

```java
public static <E> Set<E> union(Set<E> s1, Set<E> s2){
   Set<E> result = new HashSet<>(s1);
   result.addAll(S2);
   return result;
}
```

→ 경고 없이 컴파일 되며, 타입 아전하고, 쓰기도 쉽다. 직접 형변환하지 않아도 어떤 오류나 경고 없이 컴파일 된다.

- 제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽다.
- 타입과 마찬가지로, 메서드도 형변환 없이 사용할 수 있는 편이 좋으며, 많은 경우 그렇게 하려면 제네릭 메서드가 되어야 한다.
- 역시 타입과 마찬가지로, 형변환을 해줘야 하는 기존 메서드는 제네릭하게 만들자.

# 아이템 31. 한정적 와일드 카드를 사용해 API 융통성을 높이라.

매개변수화 타입: 불공변 

한정적 와일드 카드 타입 :   Iterable<? extends E>

- 특별한 매개변수화 타입을 지원
- E의 하위 타입 Iterable
- 유연성 극대화
- 입력 매개변수가 생산자와 소비자의 역할을 동시에 한다면 와일드카드 타입을 써도 좋을게 없다.
- 클래스 사용자는 와일드카드 타입이 쓰였다는 사실조차 의식하지 못하게 사용하라.
- 자바 8부터 컴파일 된다.

```java
 public void pushAll(Iterable<? extends E> src){
   for(E e : src){
     push(e);}
}
```

```java
public void popAll(collection<? super E> dst){
   while(!isEmpty())
     dst.add(pop());
}
```

### 펙스(PECS) : producer-extends, consumer-super

: 겟풋 원칙(Get and Put Priciple)

: 매개변수화 타입 T가 생산자라면 <? extends T>를 사용하고, 소비자라면 <? super T>를 사용하라.

# 아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라.

가변인수와 제네릭은 궁합이 좋지 않다.

가변 인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열은 제네릭 타입 규칙이 서로 다르지 때문이다.

: 메서드에 제네릭 varags 매개변수를 사용하고자 한다면, 먼저 그 메서드가 타입 안전한지 확인한 다음

@Safevarags 어노테이션을 달아 사용하는 데 불편함이 없게끔하자.

# 아이템 33. 타입 안전 이종 컨테이너를 고려하라.

### 이종 컨테이너 패턴(type safe heterogeneous container pattern)

: 컨테이너 대신 키를 매개변수화 한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하면 제네릭 타입 시스템이 값의타입이 키와 같음을 보장해줄 것이다.

: 데이터베이스의 행(컨테이너)을 표현한 databaseRow타입에는 제네릭 타입인 column<T>를 키로 사용

### Map<Class<?>,Object>

- 맵이 아니라 키가 와일드카드 타입 인 것,
- 모든 키가 서로 다른 매개변수화 타입일 수 있다는 뜻
- 첫번째는 Class<String>, 두번째는 Class<Integer>식으로 될 수 있다.