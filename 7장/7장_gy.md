# 7장. 람다와 스트림

- [ ]  자바 8에서 함수형 인터페이스, 람다, 메서드 참조라는 개념 추가
- [ ]  스트림 API가지 추가되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원

# 아이템42. 익명 클래스보다는 람다를 사용하라

- 익명 클래스의 인스턴스를 함수 객체로 사용 → 낡은 기법

    ```jsx
    Collections.sort(words, new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            return Integer.compare(o1.length(), o2.length());
        }
    });
    ```

- 람다식을 함수 객체로 사용 → 익명클래스 대체

    ```jsx
    Collections.sort(words, (o1, o2) -> Integer.compare(o1.length(), o2.length()));
    ```

    - 타입을 명시해야 코드가 명확할 때만 제외하고, 람다의 모든 매개변수 타입은 생략 → 컴파일러가 알아서 타입추론!
- 람다자리에 비교자 생성 메서드 사용

    ```jsx
    Collections.sort(words, Comparator.comparingInt(String::length));
    ```

- 자바8 List 인터페이스에 추가된 sort메서드 사용

    ```jsx
    words.sort(Comparator.comparingInt(String::length));
    ```

## 람다 사용시 주의점

- 람다는 메서드난 클래스와 달리 이름이 없고 문서화도 못한다.
- 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
- 3줄 이상시 가독성 떨어진다.
- 열거 타입 생성자에 넘겨지는 인수들의 타입도 컴파일타임에 추론된다. → 열거 타입 생성자 안의 람다는 열거 타입의 인스턴스 멤버에 접근할 수 없다. (인스턴스는 런타임에 생성 되기때문)
- 인스턴스 필드나 메서드를 사용해야하면 상수별 클래스 몸체를 사용해야 한다.

```jsx
//상수별 클래스 몸체 구현
PLUS("+") {
    public double apply(double x, double y) {
        return x + y;
    }
};
//람다식
PLUS("+", (x, y) -> x + y);
```

- **람다를 직렬화하는 일은 극히 삼가야 한다.**
    - 직렬화 형태가 구현별로(가상머신별로) 다를 수 있다.
    - 직렬화해야만 하는 함수 객체가 있다면(ex.Comparator) private 정적 중첩 클래스의 인스턴스를 사용하자.

## 람다로 대체할 수 없는 곳

1. 람다는 함수형 인터페이스에서만 쓰인다.
    - 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없기에 익명 클래스를 써야 한다.
    - 추상 메서드가 여러개인 인터페이스의 인스턴스를 만들때도 익명 클래스 써야한다.
2. 람다는 자기 자신을 참조할 수 없다.
    - this키워드는 바깥 인스턴스를 가리킨다.
    - 반면, 익명클래스에서의 this는 익명 클래스의 인스턴스 자신을 가리킨다.
    - 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다.

## ✏️핵심정리

익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들때만 사용하라

# 아이템43. 람다보다는 메서드 참조를 사용하라

- 람다 보다 더 간결한 방법! 메서드 참조(Method reference)
- 자바 8때 Map에 추가 된 merge메서드
    - map.merge(키, 값, 함수) → 키가 맵에 없으면 {키,값}, 없으면 {키, 함수의 결과}를 저장한다.
    - 람다식으로 구현 → count, incr는 공간만 차지

        ```jsx
        map.merge(key, 1, (count, incr) -> count + incr);
        ```

    - 메서드 참조로 구현
        - 자바 8부터 모든 기본타입의 박싱타입은 정적메서드 sum을 제공한다. → 메서드 참조를 전달하면 람다식에서 count +incr 한 것과 같은 처리

        ```jsx
        map.merge(key, 1, Integer::sum);
        ```

        - 매개변수 늘어날 수록 메서드 참조로 제거할 수 있는 코드양도 늘어난다.
- 람다로 할 수 없는 일이라면 메서드 참조도 할 수 없다.
- 람다로 구현했을 때 너무 길거나 복잡하면 메서드 참조를 대안으로 사용한다. 
→ 메서드 참조는 기능을 나타내는 이름으로 표현 가능하고 문서화도 가능하다.
- 람다가 더 간결한 경우 → 주로 메서드와 람다가 같은 클래스에 있을 때

    ```jsx
    service.execute(GoshThisClassNameIsHumongous::action);
    service.execute(() -> action());
    ```

## 🖐🏻메서드 참조유형 다섯가지

![7%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7%2069d4f6c46d8149fc9704e443095bcd74/Untitled.png](7%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7%2069d4f6c46d8149fc9704e443095bcd74/Untitled.png)

1. 정적메서드를 가리키는 메서드 참조
2. 한정적인스턴스 메서드 참조 : 수신객체(receiving Object; 참조 대상 인스턴스)를 특정한다.
    - 정적 참조 와 비슷하다.
    - 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 똑같다.
3. 비한정적인스턴스 메서드 참조 : 수신 객체를 특정하지 않는다.
    - 함수 객체를 적용하는 시점에 수신객체를 알려준다.
    - 수신 객체 전달용 매개변수가 매개변수 목록의 첫 번째로 추가되며, 그 뒤로는 참조되는 메서드 선언에 정의된 매개변수들이 뒤따른다.
    - 주로 스트림 파이프라인에서의 매핑과 필터 함수에 쓰인다.
4. 클래스 생성자를 가리키는 메서드 참조
5. 배열 생성자를 가리키는 메서드 참조

** 생성자 참조는 팩터리 객체로 사용된다.

## ✏️핵심정리

메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하자.

# 아이템44. 표준 함수형 인터페이스를 사용하라.

- 함수 객체를 매개변수로 받는 생성자와 메서드를 만들때 함수형 매개변수 타입을 올바르게 선택해야 한다.
- **람다 표현식으로 구현**이 가능한 인터페이스는 오직 **추상 메서드가 1개인 인터페이스**만 가능하다. 이 맥락에서 **추상 메서드가 1개인 인터페이스를 함수형 인터페이스**라고 한다.
- java.util.function 패키지에 다양한 용도의 표준 함수형 인터페이스를 활용하고 맞는게 없으면 구현하자.
- java.util.function 패키지에는 총 43개의 인터페이스가 있다.

## 주요 인터페이스 6가지 → 모두 참조 타입용

![7%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7%2069d4f6c46d8149fc9704e443095bcd74/Untitled%201.png](7%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B7%2069d4f6c46d8149fc9704e443095bcd74/Untitled%201.png)

### 기본 타입을 위한 표준 함수형 인터페이스

표준 함수형 인터페이스는 기본 타입인 int, long, double용으로 각 3개씩 변형이 생겨난다. 

int를 받는 Predicate는 IntPredicate가 되고, long을 받아 long을 반환하는 BinaryOperator는 LongBinaryOperator가 된다.

### Function인터페이스의 변형

- Function 인터페이스만 유일하게 매개변수화(반환타입만) 되었다.

    → ex) LongFunction<int[]>는 long인수를 받아 int[]를 반환한다.

- Function 인터페이스의 기본타입을 반환하는 변형
    - 입력과 결과 타입이 모두 기본 타입이면 접두어로 SrcToResult를 사용한다.
        - ex) long을 받아 int을 반환하면 LongToIntFunction
    - 입력이 객체 참조이고 결과가 int, long, double인 변형
        - 입력을 매개변수화하고 접두어로 ToResult를 사용한다.
        - ex) ToLongFunction<int[]>은 int[]를 인수로 받아 long을 반환한다.

Function 인터페이스 뿐만아니라 기본함수형, Consumer, Supplier, Predicate도 변형된 인터페이스들이 있지만 너무 많으니까 → 범용적인 이름 확인하고 필요하다 싶으면 사용하자.

## 표준함수형 인터페이스 사용시 주의할 점

- 표준 함수형 인터페이스 대부분은 기본 타입만 지원한다.

    → 그렇다고 **기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말자. → 성능저하**

- 코드를 직접 작성해야할 경우? → 마땅한게 없을때만!
    - Comparator<T> 인터페이스
        - 구조적으로 ToIntBiFunction<T,U>와 동일하다.
        - 인자 두 개를 받아서(Bi), 정수형을 반환하는(ToInt), 인수와 반환 타입이 다른 함수(Function)이다.
        - 하지만! 독자적인 인터페이스로 구현해야 할 충분한 이유가 있다. (아래 3조건 충족)
- 전용 함수형 인터페이스를 구현해야 하는 경우
    1. API에서 **자주 사용**되는데, **이름이 그 용도를 명확히** 드러냄
    2. 구현하는 쪽에서 **반드시 지켜야할 규약**을 담고 있다.
    3. 비교자들을 변환하고 조합해주는 **유용한 디폴트 메서드**들을 담고있다.

## @FunctionalInterface 애너테이션

- @Override를 사용하는 이유와 비슷하다. → 프로그래머의 의도를 명시
- 인터페이스가 람다용으로 설계된 것임을 알려준다.
- 해당 인터페이스가 추상메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
- 유지보수 과정에서 실수로 메서드를 추가하지 못하게 막아준다.
- **직접만든 함수형 인터페이스에는 항상 @FunctionalInterface를 사용하라.**

## 함수형 인터페이스를 API에서 사용할 때 주의점

서로 다른 함수형 인터페이스를 같은 위치의 인수로 사용하는 Override를 피해라.

- 클라이언트가 알아보기 어렵다.

```jsx
public interface ExecutorService extends Executor {
    // Callable<T>와 Runnable을 각각 인수로 하여 다중정의했다.
    // submit 메서드를 사용할 때마다 형변환이 필요해진다.
    <T> Future<T> submit(Callback<T> task);
    Future<?> submit(Runnable task);
}
```

## ✏️핵심정리

- 입력값과 반환값에 함수형 인터페이스 타입을 활용하라.
- 보통 java.util.function 패키지의 표준함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다.

# 아이템45. 스트림은 주의해서 사용하라

## 스트림API 개념

- 스트림API : 다량의 데이터 처리 작업을 위해 자바8에서 추가되었다.
- 핵심 추상개념 두 가지
    1. 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다.
    2. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.
- 스트림의 원소들은 어디로부터든 올 수 있다.
    - 컬레션
    - 배열
    - 파일
    - 정규표현식 패턴 매처
    - 난수 생성기
    - 혹은 다른 스트림
- 스트림 안의 데이터 원소들은 객체 참조나 기본 타입 값이다.
    - 기본타입 값으로는 int, long, double 지원한다.

### 스트림API는 플루언트 API 이다.

- 메서드 연쇄를 지원한다.
- 파이프라인 하나를 구성하는 모든 호출을 연결하여 단 하나의 표현식으로 완성할 수 있다.

## 스트림 파이프 라인의 특징

- 소스 스트림→ (중간연산) → 종단연산으로 끝난다.
- 중간 연산
    - 스트림을 어떠한 방식으로 변환한다.
    - ex) 각 원소에 함수 적용, 특정 조건 만족하지못하는 원소 필터링
    - 변환된 스트림의 원소타입은 전과 같을수도 다를 수도 있다.
- 종단연산
    - 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가한다.
    - ex) 원소를 정렬해 컬렉션에 담거나, 특정 원소를 하나 선택하거나, 모든 원소 출력
- 지연평가 된다.
    - 평가(호출해서 값이 사용되는)는 종단 연산이 호출될 때
    - 종단 연산에 쓰이지 않은 데이터 원소는 계산에 쓰이지 않는다.
    - 무한스트림 다룰 수 있는 열쇠
    - **종단 연산이 없는 스트림 파이프라인은 아무 일도 하지 않는다. → 빼먹지말자!**
- 순차적으로 수행된다.
- 파이프라인 병렬실행 → parallel 메서드 호출

## 스트림 사용시 주의할 점

1. 과용하면 프로그램이 읽거나 유지보수하기 어려워 진다.
2. 람다에서는 타입 이름을 자주 생략하므로 매개변수를 잘 지어야 스트림 파이프라인의 가독성이 유지 된다.
3. 도우미 메서드를 적절히 활용해야 한다. →  파이프라인에서는 타입 정보가 명시 되지 않거나 임시변수를 자주 사용하기 때문이다.
4. 자바는 char용 스트림을 지원하지 않는다. → char값 처리시 스트림 삼가하자
5. 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 나을 때만 반영하자
6. 스트림을 반환하는 메서드 이름은 원소의 정체를 알려주는 복수 명사로 사용하자

    ex) primes() :  소수 반환

## 코드블록 VS 함수객체(람다나 메서드참조)

- 되풀이되는 계산을 주로 함수객체로 표현
- 반복코드에서는 코드 블록
- 코드블록에서만 할 수 있는 일
    - 범위안의 지역변수를 읽고 수정 할 수 있다.

        ↔람다는 final 변수만 읽을 수 있고, 지연변수 수정 불가능

    - return, break, continue 가능
    - 메서드 선언에 명시된 검사 예외를 던질 수 있다.

        ↔ 람다는 다 불가

## 스트림 사용이 적당한 경우

1. 원소들의 시퀀스를 일관되게 변환한다.
2. 원소들의 시퀀스를 필터링한다.
3. 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.(sum, max, min, 연결하기)
4. 원소들의 시퀀스를 컬렉션에 모은다.(공통된 속성을 기준으로 묶어가며)
5. 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다. (filter)

## 스트림으로 처리하기 어려운 경우

한 데이터가 파이프라인의 여러단계를 통과할 때 이 데이터의 각 단계에서의 값들에 동시에 접근하기 어렵다.

- 스트림 파이프라인은 일단 한 값을 다른 값에 매핑하면 원래의 값을 잃는 구조이다.
- 가능하면, 앞 단계의 값이 필요할 때 매핑을 거꾸로 수행해야 한다.