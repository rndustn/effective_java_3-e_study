# 9장. 일반적인 프로그래밍 원칙

# 아이템57. 지역변수의 범위를 최소화하라.

지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.

## 지역변수를 잘 사용하는 방법

1. 지역변수의 범위를 줄이는 가장 강력한 방법 '가장 처음 쓰일 때 선언하기'
2. 거의 모든 지역변수는 선언과 동시에 초기화 한다.
    - try-catch 문에서는 예외

        : 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try블록 안에서 초기화 해야한다.

        → 그렇지 않으면, 예외가 블록을 넘어 메서드에까지 전파된다.

    - try 블록 바깥에서도 사용해야 한다면 try블록 앞에서 선언해야 한다.
3. 반복변수의 값을 반복문이 종료된 뒤에도 써야하는 상황이 아니라면 while문보다 for문을 쓰는 편이 낫다.

    → 반복문에서는 반복변수의 범위가 반복문의 몸체, for 키워드와 몸체 사이의 괄호 안으로 제한되기 때문

4. 메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다. → 메서드를 기능별로 쪼갠다.

## for문의 장점

- copy & paste 오류를 줄여준다.
- 변수 유효 범위가 for문 범위와 일치하여 똑같은 이름의 변수를 여러 반복문에서 써도 서로 영향이 없다.
- while문 보다 짧아서 가독성이 좋다.

# 아이템58. 전통적인 for문보다는 for-each 문을 사용하라.

## for-each문의 장점

- 반복자와 인덱스 변수를 사용하지 않아 코드가 깔끔하고 오류가 발생할 일이 없다.
- 하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지 신경쓰지 않아도 된다.
- 컬렉션을 중첩해서 순회해야 한다면 for-each 문의 이점은 더욱 커진다.
- Iterable 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.

## for문 사용시 버그

```java
...
List<Card> deck = new ArrayList<>();
for(Iterator<Suit> i = suits.iterator(); i.hasNext();)
	for(Iterator<Rank> j = ranks.iterator(); j.hasNext();)
		deck.add(new Card(i.next(), j.next());
```

→ Card에 Suit하나 당 Rank개가 매핑되야하는데 지금은 안쪽 for문에서 j 만큼 Suit가 불려지고있어서 suits의 값의 next가 더이상 없으면 NoSuchElementException을 던진다.

- 해결방법 : 바깥 반복문에 바깥 원소를 저장

    ```java
    for(Iterator<Suit> i = suits.iterator(); i.hasNext();){
    	Suit suit = i.next();
    	for(Iterator<Rank> j = ranks.iterator(); j.hasNext();)
    		deck.add(new Card(suit, j.next());
    }
    ```

- for-each 사용시 간단하게 해결가능

    ```java
    for(Suit suit : suits)
    	for(Rank rank : ranks)
    		deck.add(new Card(suit,rank));
    ```

## for-each문을 사용할 수 없는 세가지 상황

1. 파괴적인 필터링

    : 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove메서드를 호출해야 한다.

    → 자바8부터는 Collection의 removeIf메서드를 사용해 컬렉션을 명시적으로 순회하지 않아도 된다.

2. 변형

    : 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.

3. 병렬 반복

    : 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

# 아이템59. 라이브러리를 익히고 사용하라.

## 표준 라이브러리 사용 이점

1. 라이브러리 코드를 작성한 전문가의 지식과 경험을 활용 할 수 있다.
2. 핵심적인 일과 크게 관련 없는 문제 해결에 시간낭비하지 않아도 된다.
3. 따로 노력없이 성능이 지속적으로 개선된다.
4. 기능이 점점 많아진다.
5. 가독성, 유지보수, 재활용이 쉬운 코드가 된다.

알아두면 큰 도움이 되는 라이브러리

1. 컬렉션 프레임워크
2. 스트림
3. java.util.concurrent의 동시성 기능

# 아이템60. 정확한 답이 필요하다면 float와 double은 피하라.

- float와 double 타입은 특히 금융 관련 계산과 맞지 않는다.

    → 0.1 혹은 10의 음의 거듭 제곱 수 (10^-1, 10^-2 등)을 표현할 수 없기 때문이다.

    ex) 1.03 - 0.42 = 0.610000000000001을 출력한다.

- 금융계산에는 BigDecimal, int 혹은 long을 사용해야 한다.
- BigDecimal의 단점
    1. 기본 타입보다 쓰기 불편하다.
    2. 훨씬 느리다.
- BigDecimal의 대안으로 int 혹은 long 타입을 쓸 수도 있다.
    1. 다룰 수 있는 값의 크기가 제한된다.
    2. 소수점을 직접 관리해야 한다.

## ✏️핵심정리

- 코딩 시 불편함이나 성능 저하를 신경쓰지 않아도 되면 BigDecimal을 사용하라.
- BigDecimal이 제공하는 반올림 모드를 이용하여 완벽히 제어 가능하다.
- 성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int나 long을 사용하라.
- 숫자를 9자리 십진수 표현 int
- 18자리 십진수 표현 long
- 18자리 이상 BigDecimal 사용해야 한다.

# 아이템61. 박싱된 기본 타입보다는 기본 타입을 사용하라.

- 기본타입 : int, double, boolean, ..
- 참조타입: String, List,..
- 박싱된 기본타입: Integer, Double, Boolean,..

## 기본 타입과 박싱된 기본 타입의 차이점

1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이란 속성을 갖는다.

    → 박싱된 기본 타입의 두 인스턴스는 같은 값을 가지고 있어도 서로 다르다고 식별된다.

2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

## 박싱타입 사용시 주의할 점

1. 같은 객체를 비교하는게 아니라면 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.
2. 기본 타입과 박싱된 기본타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.
3. null참조를 언박싱하면 NPE이 발생한다.
4. 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.

## 박싱된 기본타입 사용에 적절한 경우

1. 컬렉션의 원소, 키, 값으로 쓴다.
    - 컬렉션은 기본타입을 담을 수 없으므로 박싱된 기본타입을 써야한다.
2. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본타입을 써야한다.
3. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

# 아이템62. 다른 타입이 적절하다면 문자열 사용을 피하라.

## 문자열을 쓰지말아야 하는 이유

1. 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
    - 문자열로 받은 데이터가 수치형이면 int, float, BigInteger 등 적당한 수치타입으로 변환해야 한다.
    - 예/아니오 질문의 답이라면 적절한 열거타입이나 boolean으로 변환해야 한다.
    - 적절한 값 타입이 있다면 그것을 사용하고, 없다면 새로 작성해야 한다.
2. 문자열은 열거 타입을 대신하기에 적합하지 않다.
    - 상수를 열거할 때는 문자열보다 열거 타입이 월등히 낫다.
3. 문자열은 혼합 타입을 대신하기에 적합하지 않다.

    ```java
    String compoundKey = className + "#" + i.next();
    ```

    - 각 요소를 개별로 접근하려면 문자열을 파싱해야해서 느리고,오류 가능성도 커진다.
    - 적절한 equals, toString, compareTo 메서드를 제공할 수 없다.
4. 문자열은 권한을 표현하기에 적합하지 않다.
    - 문자열을 사용해 권한을 구분한 예

        ```java
        public class ThreadLocal {
        	private ThreadLocal() {} // 객체 생성 불가
        	//현 스레드의 값을 키로 구분해 저장한다.
        	public static void set(String key, Object value);
        	//(키가 가리키는) 현 스레드의 값을 반환한다.
        	public static Object get(String key);
        }
        ```

        - 문제점: 스레드 구분용 문자열 키가 전역 이름 공간에 공유 된다.
        - 각 클라이언트가 고유한 키를 제공해야하는데 같은 키 제공하면 같은 값을 공유하게 된다.
        - 보안 취약
    - 별도의 타입인 Key 클래스로 권한을 구분한 예

        ```java
        public class ThreadLocal {
        	private ThreadLocal() {} // 객체 생성 불가
        	public static class Key { // (권한)
        		key(){}
        	}
        	//위조 불가능한 고유 키를 생성한다.
        	public static Key getKey(){
        		return new Key();
        	}
        	public static void set(Key key, Object value);
        	public static Object get(Key key);
        ```

        - set/ get 메서드는 이제 정적 메서드일 이유가 없으니, Key 클래스의 인스턴스 메서드로 바꿔준다.

            → key는 더이상 스레드 지역변수를 구분하기 위한 키가 아니라, 그 자체가 스레드 지역변수가 된다.

    - 리팩터링

        ```java
        public final class ThreadLocal<T> {
        	public ThreadLocal();
        	public void set(T value);
        	public T get();
        }
        ```

        - 위 코드에서 톱클래스 ThreadLocal 부분은 필요없으니 지우고 중첩클래스 Key이름을 ThreadLocal로 변경해준다.
        - get으로 얻은 Object를 실제 타입으로 형변환해야해서 타입안전하지 않으니 타입안전을 위해 ThreadLocal을 매개변수화 타입으로 선언한다.

# 아이템63. 문자열 연결은 느리니 주의하라.

문자열 연결 연산자 (+)는 여러 문자열을 하나로 합려주는 편리한 수단이다.

문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례한다.

문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야하므로 성능저하는 피할 수 없다.

**성능을 위해서는 String 대신 StringBuilder를 사용하자.**

```java
Public String statement(){
	StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH);
	for (int i = 0; i < numItems(); i++)
		b.append(lineForItem(i));
	return b.toString();
}
```

# 아이템64. 객체는 인터페이스를 사용해 참조하라.

아이템51. 매개변수 타입으로 클래스가 아니라 인터페이스를 사용하라의 확장!

## 적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.

- 객체의 실제 클래스를 사용해야 할 상황은 '오직' 생성자로 생성할 때뿐이다.
- 좋은 예시

    ```java
    Set<Son> sonSet = new LiskedHashSet<>();
    ```

- 나쁜 예시

    ```java
    LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
    ```

- 인터페이스를 타입으로 사용하면 프로그램이 훨씬 유연해진다.
    - 구현 클래스 교체시 새클래스의 생성자 혹은 정적팩터리를 호출해주면 된다.

    ```java
    Set<Son> sonSet = new HashSet<>();
    ```

- 변수를 구현 타입(클래스)로 선언하고 선언타입, 구현 타입을 변경하면 오류가 발생할 수 있다.
    - 클라이언트에서 기존 타입에서만 제공하는 메서드를 사용했거나, 기존타입을 사용해야 하는 다른 메서드에 그 인스턴스를 넘겼다면 새로운 코드에서는 컴파일되지 않는다.

## 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.

1. String, BigInteger 같은 값 클래스
    - 값 클래스를 여러 가지로 구현될 수 있다고 설계하는 일은 거의 없어서 final인 경우가 많고 상응하는 인터페이스가 별도로 존재하는 경우가 드물다.
    - 이런 값 클래스는 매개변수, 변수필드, 반환타입으로 사용해도 무방하다.
2. 클래스 기반으로 작성된 프레임워크가 제공하는 객체
    - 특정 구현 클래스보다는 (보통 추상 클래스인) 기반 클래스를 참조하는 게 좋다.
    - ex) OutputStream 등 [java.io](http://java.io) 패키지의 여러 클래스
3. 인터페이스에는 없는 특별한 메서드를 제공하는 클래스
    - ex) PriorityQueue 클래스는 Queue 인터페이스에 없는 comparator메서드를 제공한다.
    - 클래스 타입을 직접 사용하는 경우는 이런 추가 메서드를 꼭 사용해야하는 경우로 최소화해야 한다.

## 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스 타입으로 사용하자.

# 아이템65. 리플렉션보다는 인터페이스를 사용하라.

- 리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.
- Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고, 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다.
- Constructor, Method, Field 인스턴스를 이용해 각각에 연결된 실제 생성자, 메서드, 필드를 조작하여 해당 클래스의 인스턴생성, 메서드 호출, 필드 접근이 가능하다.

    ex) Method.invoke는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있게 해준다.

- 리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있다.

## 리플렉션 사용시 단점

1. 컴파일타임 타입 검사와 예외검사가 주는 이점을 하나도 누릴 수 없다. → 잘못 작성시 런타임 오류
2. 코드 가독성이 떨어진다.
3. 성능이 떨어진다.
4. 아주 제한된 형태로만 사용해야 단점을 피할 수 있다.
5. 컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램 → 비록 컴파일타임이라도 적절한 인터페이스나 상위클래스를 이용해야한다. 이 경우 **리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 적절한 인터페이스나 컴파일타임에 알 수 있는 상위 클래스로 형변환해 사용해야 한다.**

    ```java
    public static void main(String[] args) {

        // 클래스 이름을 Class 객체로 변환
        Class<? extends Set<String>> cl = null;
        try {
          cl = (Class<? extends Set<String>>)  // 비검사 형변환, @SuppressWarnings을 쓰고 주석을 달아야 한다.item27
              Class.forName("java.util.HashSet");
        } catch (ClassNotFoundException e) {
          fatalError("클래스를 찾을 수 없습니다.");
        }

        // 생성자를 얻는다.
        Constructor<? extends Set<String>> cons = null;
        try {
          cons = cl.getDeclaredConstructor(); // java.lang.reflect 사용
        } catch (NoSuchMethodException e) {
          fatalError("매개변수 없는 생성자를 찾을 수 없습니다.");
        }

        // 집합의 인스턴스를 만든다.
        Set<String> s = null;
        try {
          s = cons.newInstance();  // java.lang.reflect 사용
        } catch (IllegalAccessException e) {
          fatalError("생성자에 접근할 수 없습니다.");
        } catch (InstantiationException e) {
          fatalError("클래스를 인스턴스화할 수 없습니다.");
        } catch (InvocationTargetException e) {
          fatalError("생성자가 예외를 던졌습니다: " + e.getCause());
        } catch (ClassCastException e) {
          fatalError("Set을 구현하지 않은 클래스입니다.");
        }

        // 생성한 집합을 사용한다. 상위 인터페이스인 Set의 메서드를 사용
        s.addAll(Arrays.asList("a","b","c").subList(1, 3));
        System.out.println(s);
      }

      private static void fatalError(String msg) {
        System.err.println(msg);
        System.exit(1);
      }
    }
    ```

    1. forName()에 String 형태의 클래스 파일명을 넣어주면 해당하는 클래스를 반환해준다. 단, 실제 클래스가 만들어진 것은 아니라서 메모리에 올라오지 않았다.
    2. newInstance() 를 사용해서 클래스의 인스턴스를 만들어준다.
    3. java.io.reflect가 제공해준 생성자로 인스턴스를 생성한 이후 부터는 reflect의 기능을 쓰지 않고 인터페이스나 상위 클래스를 참조해서 사용한다.

    위 예시가 보여주는 리플렉션의 단점

    1. 리플렉션을 사용하지 않았다면 컴파일타임에 잡을 수 있는 예외를 6가지나 던진다.

        → 자바7부터는 코드를 줄이기 위해 java.io.reflect의 최상위 오류인 ReflectiveOperationException 을 사용해도 된다.

    2. 클래스 이름만으로 인스턴스를 생성하기 위해 25줄이나 되는 코드를 작성한다.

## 리플렉션 사용이 적절한 경우

- 런타임에 존재하지 않을 수도 있는 다른 클래스, 메서드, 필드와의 의존성을 관리할 때 적합하다.

    → 버전이 여러 개 존재하는 외부 패키지를 다룰 때 유용하다.

    가동할 수 있는 최소한의 환경, 즉 주로 가장 오래된 버전만을 지원하도록 컴파일한 후, 이후 버전의 클래스와 메서드 등은 리플렉션으로 접근하는 방식이다.

    → 접근하려는 새로운 클래스나 메서드가 런타임에 존재하지 않을 수 있다는 사실을 감안해야 한다.

    즉, 같은 목적을 이룰 수 있는 대체 수단을 이용하거나 기능을 줄여 동작하는 등의 적절한 조치를 취해야 한다.

# 아이템66. 네이티브 메서드는 신중히 사용하라.

- 자바 네이티브 인터페이스(JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기능이다.
- 네이티브 메서드 : C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드

## 네이티브 메서드의 주요 쓰임

1. 레지스트리 같은 플랫폼 특화 기능을 사용한다.
    - 자바9은 새로 process API를 추가해 OS프로세스에 접근하는 길을 열어 점차 하부 플랫폼의 기능들을 자바가 흡수하고 있다. → 네이티브 메서드 필요 감소
2. 네이티브 코드로 작성된 기존 라이브러리를 사용한다.
    - 대체할 만한 자바 라이브러리가 없는 네이티브 라이브러리 사용시에 사용한다.
3. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.
    - JVM의 발전으로 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다.
    - 고성능의 다중 정밀 연산 라이브러리(GMP)가 필요한 경우라면 네이티브 메서드를 고려해도 좋다.

## 네이티브 메서드의 단점

- 네이티브 언어가 안전하지 않으므로(버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌)네이티브 메서드를 사용하는 애플리케이션도 메모리훼손 오류로부터 안전하지 않다.
- 자바보다 플랫폼을 많이 타서 이식성이 낮다.
- 디버깅이 어렵다.
- 속도가 오히려 느려질 수 있다.
- GC가 네이티브 메모리는 자동 회수하지 못하고, 심지어 추적할 수도 없다.
- 자바 ↔ 네이티브 코드 넘나들때마다 비용도 추가된다.
- 네이티브 메서드와 자바 코드 사이의 접착코드를 작성해야하는데 귀찮고 가독성이 떨어진다.

# 아이템67. 최적화는 신중히 하라.

- 빠른 프로그램보다는 좋은 프로그램을 작성하라.

    구현상의 문제는 나중에 최적화해 해결할 수 있지만, 아키텍처의 결함이 성능을 제한한다면 시스템 전체를 다시 작성하지 않고는 해결하기 불가능 할 수 있다.

- 성능을 제한하는 설계를 피하라.

    완성 후 변경하기 가장 어려운 설계요소 : 컴포넌트끼리, 혹은 외부 시스템과의 소통방식

    ex) API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등

- API를 설계할 떄 성능에 주는 영향을 고려하라.
    - public 타입을 가변으로 만들면, 불필요한 방어적 복사를 수없이 유발할 수 있다.
    - 컴포지션으로 해결할 수 있음에도 상속 방식으로 설계한 public클래스는 상위 클래스에 종속되며 그 성능의 제약까지 물려받는다.
    - 인터페이스가 있는 경우 굳이 구현 타입을 사용하는 것도 좋지 않다. → 특정 구현체에 종속되어 나중에 더 빠른 구현체가 나오더라도 이용하지 못하게 된다.
- 성능을 위해 API를 왜곡하는 건 매우 안 좋은 생각이다.
    - 성능 문제는 해당 플랫폼이나 아랫단 소프트웨어의 다음 버전에서 사라질 수 있지만, 왜곡된 API 지원은 계속 문제가 될 것이다.
- 각각의 최적화 시도 전후로 성능을 측정한다.
- 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행할 수 있다. (개별 메서드의 소비시간과 호출 횟수 같은 런타임 정보를 제공하고, 알고리즘을 변경해야한다는 사실을 알려주기도 한다.)
- 자바는 코드와 CPU에서 수행하는 명령사이의 추상화 격차가 커서 최적화로 인한 성능 변화를 일정하게 예측하기 어렵다.
- 자바의 성능 모델은 구현 시스템, 릴리즈, 프로세서마다 차이가 있어 각각 측정해야 한다.

# 아이템68. 일반적으로 통용되는 명명 규칙을 따르라.

자바의 명명 규칙은 크게 철자와 문법 두 범주로 나뉜다.

## 철자 규칙

- 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름을 다룬다.

### 1. 패키지 명명 규칙

- 패키지와 모듈 이름은 각 요소를 점(.)으로 구분하여 계층적으로 짓는다.
- 요소들은 모두 소문자 알파벳 혹은 (드물게) 숫자로 이뤄진다.
- 조직 바깥에서도 사용될 패키지라면 조직의 인터넷 도메인 이름을 역순으로 사용한다.

    ex) edu.cmu, com.google, org.eff, com.nsmall

- 예외적으로 표준 라이브러리와 선택적 패키지들은 각각 java와 javax로 시작한다.
- 도메인 이름을 패키지 이름의 접두어로 변환하는 자세한 규칙은 자바 언어 명세에 적혀있다.
- 패키지 이름의 나머지는 해당 패키지를 설명하는 하나 이상의 요소로 이뤄진다.
- 각 요소는 일반적으로 8자 이하의 짧은 단어로 한다. (utilities → util)
- 여러 단어로 구성된 이름이라면 awt처럼 각 단어의 첫글자만 따서 써도 된다.
- 많은 기능을 제공하는 경우엔 계층을 나눠 더 많은 요소로 구성해도 좋다.

### 2. 클래스와 인터페이스 명명 규칙

- 열거 타입과 애너테이션도 동일한 규칙
- 하나 이상의 단어로 이뤄지며, 각 단어는 대문자로 시작한다.
- 여러 단어의 첫 글자만 딴 약자나 max, min 처럼 널리 통용되는 줄임말을 제외하고는 단어를 줄여 쓰지 않도록 한다.

### 3. 메서드와 필드 이름 명명 규칙

- 첫 글자를 소문자로 쓴다는 점만 빼만 클래스 명명 규칙과 같다.
- 첫 단어가 약자라면 단어 전체가 소문자여야 한다.
- 단, 상수필드는 예외다.
    - 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 밑줄로 구분한다.
    - ex) VALUES, NEGATIVE_INFINITY 등
    - 상수 필드는 값이 불변인 static final 필드를 말한다.
    - static final 필드의 타입이 기본 타입이나 불변 참조 타입이라면 상수 필드에 해당한다.
    - static final 필드이면서 가리키는 객체가 불변이라면 비록 그 타입은 가변이라도 상수 필드다.
    - 이름에 밑줄을 사용하는 요소로는 상수 필드가 유일하다.

### 4. 지역변수 명명 규칙

- 다른 멤버와 비슷한 명명 규칙이 적용된다.
- 단, 약어를 써도 좋다.
- 입력 매개변수도 지역변수의 하나지만, 일반 지역 변수보다는 신경을 써야한다.

### 5. 타입 매개변수 명명 규칙

- 보통 한 문자로 표현한다.
    1. 임의의 타입 : T
    2. 컬렉션 원소의 타입 : E
    3. 맵과 키의 값 : K, V
    4. 예외 : X
    5. 메서드의 반환 타입 : R
    6. 그 외의 임의 타입의 시퀀스에는 T, U, V 혹은 T1, T2, T3를 사용한다.

[철작 규칙 정리](https://www.notion.so/2a72202222834e59868d942182242984)

## 문법 규칙

- 철자 규칙보다 유연하고 논란이 많다.

### 1. 패키지 명명 규칙

- 따로 없다.

### 2. 객체를 생성할 수 있는 클래스 명명 규칙 (열거 타입 포함)

- 보통 단수 명사나 명사구를 사용한다.
- ex) Thread, PriorityQueue, ChessPiece 등

### 3. 객체를 생성할 수 없는 클래스 명명 규칙

- 보통 복수형 명사로 짓는다.
- ex) Collectors, Collections 등

### 4. 인터페이스 명명 규칙

- 클래스와 똑같이 짓거나
- ex) Collector, Collection 등
- able 혹은 ible로 끝나는 형용사로 짓는다.
- ex) Runnable, Iterable, Accessible 등

### 5. 애너테이션 명명 규칙

- 지배적인 규칙없이 명사, 동사, 전치사, 형용사가 두루 쓰인다.
- ex) BindingAnnotation, Inject, ImplementedBy, Singleton 등

### 6. 메서드 명명 규칙

- 동사나 (목적어를 포함한) 동사구로 짓는다.
- ex) append, drawImage
- boolean 값을 반환하는 메서드라면 보통 is나 has로 시작하고 명사나 명사구, 혹은 형용사로 기능하는 아무단어나 구로 끝나도록 짓는다.
- ex) isDigit, isProbablePrime, isEmpty, isEnabled, hasSiblings 등
- 반환 타입이 boolean이 아니거나 해당 인스턴스의 속성을 반환하는 메서드의 이름은 보통 명사, 명사구, 혹은  get으로 시작하는 동사구로 짓는다.
- ex) size, hasCode, getTime 등
- 클래스가 한 속성의 게터와 세터를 모두 제공할 때 getAttribute 와 setAttribute 형태의 이름을 갖게된다.

### 꼭 언급되야 할 특별한 메서드 이름

1. 객체의 타임을 바꿔서 다른 타입의 또 다른 객체를 반환하는 인스턴스 메서드의 이름은 보통 toType형태로 짓는다.

    ex) toString, toArray 등

2. 객체의 내용을 다른 뷰로 보여주는 메서드의 이름은 asType 형태로 짓는다.

    ex) asList 등

3. 객체의 값을 기본 타입 값으로 반환하는 메서드의 이름은 보통 typeValue 형태로 짓는다.

    ex) intValue 등

4. 정적 팩터리 이름은 다양하지만 from, of, valueOf, instance, getInstance, newInstance, getType, newType을 흔히 사용한다.

### 7. 필드 이름 명명 규칙

- boolean 타입의 필드 이름은 보통 boolean 접근자 메서드에서 앞 단어를 뺀 형태다.
- ex) initialized, composite 등
- 그 외 타입 필드는 명사나 명사구를 사용한다.
- ex) height, digits, bodyStyle 등

### 8. 지역변수 명명 규칙

- 필드와 비슷하나 더 유연하다.