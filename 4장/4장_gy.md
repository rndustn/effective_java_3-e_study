# 4장. 클래스와 인터페이스

- [ ]  클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만드는 방법을 다룬다.

# 아이템15. 클래스와 멤버의 접근 권한을 최소화하라.

## 📌정보은닉이란?

클래스 내부 데이터와 내부 구현 정보(메서드)를 하나의 클래스로 묶고 외부 컴포넌트로 부터 완벽히 숨겨 구현과 API를 완벽히 분리한다. 
오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작방식에는 전혀 개의치 않는다.
→ 객체에 직접적인 접근을 막고 외부에서 내부의 정보에 직접접근하거나 변경할 수 없고, 객체가 제공하는 필드와 메소드를 통해서만 접근이 가능하다.

## 👍🏻정보은닉(캡슐화)의 장점

1. 시스템 개발속도 향상 : 여러 컴포넌트를 병렬로 개발 할 수 있기 때문이다.
2. 시스템 관리비용 절감 : 각 컴포넌트 더 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문이다.
3. 성능 최적화에 도움 : 최적화 대상 컴포넌트를 정한 후 다른 컴포넌트에 영향없이 해당 컴포넌트만 최적화 할 수 있기 때문이다. 
4. 소프트웨어 재사용성 상승 : 외부에 거의 의존하지 않고 독자적으로 동작가능한 컴포넌트라면 다른 환경에서도 재사용 가능하기 때문이다.
5. 큰 시스템을 제작하는 난이도 감소 : 시스템 전체가 완성되지 않은 상태에서 개별 컴포턴트의 동작을 검증할 수 있기 때문이다.

## ✨정보은닉의 핵심 : 접근제한자의 활용

### 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.

→ 소프트웨어가 올바로 동작하는 한 항상 낮은 접근 수준을 부여해야 한다는 뜻이다.

### 클래스의 접근제한자

1. 톱레벨 클래스(가장 바깥)와 인터페이스에 부여할 수 있는 접근 수준은 package-private와 public 두 가지이다.
    - **public** 선언 : 공개 API →  하위 호환을 위해 영원히 관리해줘야 한다.
    - **package-private** 선언 : 해당 패키지 안에서만 이용 → 확장, 수정, 교체, 제거에 용이
2. **한 클래스에서만 사용하는** package-private 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스안에 **private static으로 선언한다.**
→ 톱레벨로 두면 같은 패키지의 모든 클래스가 접근할 수 있지만, private static을 중첩시키면 바깥 클래스 하나에서만 접근 할 수 있다.
3. public일 필요가 없는 클래스의 접근 수준을 package-private 톱레벨 클래스로 좁혀야 한다.
→ public 클래스는 그 패키지의 API인 반면, **package-private 톱레벨 클래스는 내부구현이다.**

### 멤버(필드, 메서드, 중첩클래스, 중첩인터페이스) 접근제한자의 종류

1. private : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
2. package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.
접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근수준이다.
package-private은 default 제어자랑 같은 의미로 사용된다.
3. protected : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래서에도 접근할 수 있다.
4. public : 모든 곳에서 접근 할 수 있다.

## ❗접근제한자 구현시 주의할 점

private와 package-private 멤버는 모두 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다. 단, Serializable을 구현한 클래스에서는 의도치 않게 공개 API가 될 수 있다.

1. 클래스의 공개 API를 세심히 설계 후, 그 외의 모든 멤버는 private로 선언한다.
2. 같은 패키지의 다른 클래스가 접귾야하는 멤버는 package-private로 풀어준다.
3. public 클래스에서는 멤버의 접근 수준을 package-private에서 protected로 변경한 순간 접근가능 대상 범위가 엄청나게 넓어진다. →적을수록 좋다.

### 멤버 접근성을 좁히지 못하게 방해하는 제약

상위클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.

→ 리스코프 치환 원칙( 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다.)

단, 클래스가 인터페이스를 구현하는 경우에는 클래스의 메서드를 모두 public으로 선언해야 한다.

단지 테스트 목적으로 접근 범위를 넓히더라도 public 클래스의 private 멤버를 package-private(default)까지 풀어주는 것은 허용할 수 있지만, 그 이상(공개API가 되는)은 안 된다.

 

### public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.

- 필드가 가변 객체(컬렉션이나 배열)를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드를 담을 수 있는 값을 제한할 힘을 잃게된다. → 불변식을 보장할 수 없다.
- public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
- 상수라면 public static final 필드로 공개해도 된다.
→ 이런 필드는 반드시 기본 타입 값이나 불변객체를 참조해야 한다.
→ 가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다.
( 다른 객체를 참조하지는 못하지만, 참조된 객체 자체는 수정될 수 있기 때문 )

### 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.

- 길이가 0이 아닌 배열은 모두 변경 가능하다.
- 클라이언트에서 배열의 내용을 수정할 수 있게된다.
→ 값이면 수정 불가능하겠지만 배열인 경우 값이 그냥 값이 아닌 주소값이 때문에 변경이 가능하다.

    ```jsx
    public static final Thing[] VALUES = {...};
    ```

🛠️**해결방안**

1. public 배열을 private로 만들고 public 불변리스트를 추가한다.

    ```jsx
    private static final Thing[] PRIVATE_VALUES = {...};
    public static final List<Thing> VALUES = 
    	Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
    ```

2. 배열을 private로 만들고 그 복사본을 반환하는 public 메서드를 추가한다. (방어적 복사)

    ```jsx
    private static final Thing[] PRIVATE_VALUES = {...};
    public static final Thing[] values() {
    	return PRIVATE_VALUES.clone();
    }
    ```

## **Java9의 Module System**

**패키지가 클래스들의 묶음이듯, 모듈은 패키지들의 묶음이다.**

- 자신이 속하는 패키지 중 공개(export)할 것들을 (관례상 [module-info.java](http://module-info.java) 파일에) 선언한다.
- protected 혹은 public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서 접근할 수 없다.
- 모듈 시스템을 활요하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다.

암묵적 접근 수준 : public과 protected 수준과 같으나 모듈 내부로 한정

- 모듈 내부의 public: 모듈 내부의 모든 곳에서 접근할 수 있다.
- required의 public: 모듈에 종속하는 모듈의 모든 패키지 내의 클래스에 접근할 수 있다.
- export public: module-info.java에서 제공하는 모든 public에 접근할 수 있다.

## ✏️핵심 정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라
- 꼭 필요한 것만 골라 최소한의 public API를 설계하라
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.
- public static final 필드가 참조하는 객체가 불변인지 확인하라

# 아이템16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.

```jsx
class Point{
  public double x;
  public double y;
}
```

- 이런 클래스는 데이터 필드에 직접 접근할 수 있어 캡슐화의 이점을 제공하지 못한다.
- API를 수정하지 않고는 내부 표현을 바꿀 수 없다.
- 불변식을 보장할 수 없다.
- 외부에서 필드에 접근할 때 부수 작업을 수행할 수 없다.
- public 필드를 사용하는 클라이언트가 생겨 내부 표현방식을 마음대로 바꿀 수 없다.

## 접근자와 변경자 메서드를 활용해 데이터를 캡슐화 한다.

→ 필드를 모두 private으로 바꾸고 public 접근자(getter)를 추가한다.

```jsx
class Point{
	private double x;
	private double y;   	
	public Point(double x, double y){
		this.x = x;
		this.y = y;
	}    
	public double getX() { return x; }
	public double getY() { return y; }
    
	public void setX(double x){ this.x = x; }
	public void setY(double y){ this.y = y; }
}
```

패키지 외부에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 **클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.**(getter, setter 혹은 또 다른 메서드를 통해 로직 추가가능)

## package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 문제가 없다.

→ 같은 패키지안에서 특정이유 때문에 사용하던가, 톱레벨 클래스에서만 접근 할 것이기 때문이다.

수정범위

- package-private : 패키지 바깥 코드를 손대지 않고 데이터 표현 방식을 바꿀 수 있다.
- private 중첩 : 이 클래스를 포함하는 외부 클래스까지로 제한한다.

### public 클래스의 불변필드

직접 노출할 때의 단점이 조금 줄어들지만 API를 변경하지 않고는 표현 방식변경이 불가하고 필드를 읽을 때 부수작업 수행불가의 단점이 여전하다. 단, 불변식은 보장할 수 있게 된다.

## ✏️핵심 정리

- public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다.
- 불편 필드라면 노출해도 덜 위험하지만 완전히 안심할 수 없다.
- package-private 클래스나 private 중첩 클래스에서는 종종(불변이든 가변이든) 필드를 노출하는 편이 나을 때도 있다.

# 아이템17. 변경 가능성을 최소화하라.

## 📌불변 클래스란?

- **인스턴스의 내부 값을 수정할 수 없는 클래스**
- 자바의 불변 클래스 : String, Boxing Class, BigInteger, BigDecimal
- 불변 클래스는 가변 클래스보다 설계하고 사용하기 쉬우며, 오류가 생길 여지도 적도 훨씬 안전하다.

## ✔️불변 클래스 만들기 위한 다섯 가지 규칙

1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다. (Setter)
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final로 선언한다.
    - 설계자의 의도 명확히 드러내는 방법이다.
    - 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장한다.
4. 모든 필드를 private으로 선언한다.
    - 필드가 참조하는 가변 객체를 클라이언트가 직접 수정하는 일을 막아준다.
    - 기본 타입 필드나 불변 객체를 참조하는 필드를 public final로만 선언해도 불변 객체가 되지만, 다음 릴리즈에서 내부표현을 변경하지 못하므로 권하지 않음
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
    - 클라이언트에서 인스턴스 내에 가변 객체의 참조를 얻을 수 없게 해야한다.
    - 접근자 메서드가 그 필드를 그대로 반환하면 안된다. ( Collection에 대한 getter를 제공하면 안된다.)
    - 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행해야 한다.

## 함수형 프로그래밍

- 피연산자에 함수를 적용해 그 결과를 반환한다.
- 피연산자에 대한 연산을 하지만 피연산자 자체의 값은 그대로 변하지 않는다.
↔절차적 혹은 명령형 프로그래밍에서 피연산자인 자신을 수정해 자신의 상태가 변한다.
- 메서드 이름으로 (add같은) 동사 대신 (plus같은) 전치사를 사용하여 해당 메서드가 객체의 값을 변경하지 않는다는 사실을 강조한다.
- 코드에서 불변이 되는 영역의 비율이 높아진다.

## 👍🏻불변 객체의 장점

1. 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.
2. 모든 생성자가 클래스 불변식을 보장한다면 그 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않더라도 영원히 불변으로 남는다.
3. 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다.
4. 불변 객체는 안심하고 공유할 수 있다. → 최대한 재활용해라
    - 자주 쓰이는 값들을 상수(public static final)로 제공한다.
    - 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 인스턴스 중복생성을 막아주는 정적 팩터리를 제공할 수 있다. (박싱된 기본 타입 클래스와 BigInteger)
    → 새로운 클래스 설계시 public 생성자 대신 정적팩터리 만들어두면 클라이언트 수정없이 필요에 따라 캐시 기능을 추가할 수 있다.
5. 불변 객체는 바뀌지 않으므로 방어적 복사가 필요없다.
clone 메서드나 복사 생성자를 제공하지 않는게 좋다.
6. 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
7. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.
    - 구조가 복잡하더라도 불변식을 유지하기 수월하다.
    - Map의 Key
    - Set의 원소
8. 불변 객체는 그 자체로 실패 원자성을 제공한다.
실패 원자성 : 메서드에서 예외가 발생한 후에도 그 객체는 메서드 호출전 상태와 같은 유효한 상태를 가진다.

## 👎🏻불변 객체의 단점

값이 다르면 반드시 독립된 객체로 만들어야 한다. → 값의 가짓수가 많을수록 생성 비용증가

1. 백만 비트짜리 BigInteger에서 비트하나만 바꿔야 해도 새로운 인스턴스 생성 (O(N))
2. BigSet은 원하는 비트 하나만 상수 시간안에 바꿔주는 메서드를 제공한다. (O(1))
BigInteger와 같이 임의 길이의 비트 순열을 표현하지만, 가변이다. 

### 불변객체 단점에 대처하는 두가지 방법

1. 흔히 쓰일 다단계 연산들을 예측하여 기본 기능으로 제공한다.
→ 각 단계마다 객체를 생성하지 않아도 된다.
    - 다단계 연산 속도를 높여주는 **가변 동반 클래스(companion class)를 package-private**으로 두고 있다.
    - **가변 동반 클래스란?**

        불변 클래스와 거의 동일한 기능을 가지고 있지만 가변적인 클래스를 가변 동반 클래스라고 한다. 가변 동반 클래스는 주로 불변 클래스가 비즈니스 로직 연산 등 시간 복잡도가 높은 연산시 불필요한 클래스 생성을 막기 위해 내부적으로 사용한다.
        대표적으로, 불변 클래스인 String에게 가변 동반 클래스인 StringBuffer가 있다.

2. 예측이 안된다면, 가변 동반 클래스를 public으로 제공하는 게 최선이다.

## 불변 클래스 설계방법

1. final 클래스로 선언하여 상속을 막는다.
2. 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공한다.

    ```jsx
    public Class Complex {
        private final double re;
        private final double im;

        private Complex(double re, double im) {
            this.re = re;
            this.im = im;
        }
        public static Complex valudOf(double re, double im) {
            return new Complex(re, im);
        }
        ...
    }
    ```

    - 외부에서 볼 수 없는 package-private 구현 클래스를 원하는 만큼 생성, 활용 가능
    - 패키지 외부의 클라이언트에서 본 이 불변객체는 사실상 final이다.
    - public이나 protected생성자가 없으니 다른 패키지에서 클래스 확장이 불가능하다.
3. 정적 팩터리 방식은 다수의 구현 클래스를 활용한 유연성을 제공한다.
4. 다음 릴리즈에서 객체 캐싱을 추가해 성능을 끌어 올릴 수 있다.

## ❗BigInteger와 BigDecimal 설계시 주의할 점

재정의 할 수 있도록 설계되어 신뢰할 수 없는 하위 클래스의 인스턴스라고 확인되면, 이 인수들을 가변이라 가정하고 **방어적으로 복사**해 사용해야 한다.

```jsx
public static BigInteger safeInstance(BigInteger val) {
    return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());
}
```

## 불변 클래스의 규칙 중 "모든 필드가 final이고 어떤 메서드도 그 객체를 수정할 수 없다"→ 성능을 위한 완화

**"어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다."**

어떤 불변 클래스는 계산비용이 큰 값을 처음 쓰일 때 계산하여 **final이 아닌 필드에 캐시**해 놓는다.

→ 같은 값 재요청시 캐시 값 반환하여 계산비용 절감(항상 같은 결과 보장되기 때문)

실제로 String 클래스는 불변객체이지만, final이 아닌 필드 hash를 이용해 캐시하여 hashcode 재 연산 비용을 줄인다.

**직렬화할 경우 추가 주의점**

Serializable을 구현하는 불변 클래스의 내부에 가변 객체를 참조하는 필드가 있다면 readObject나 readResolve 메서드를 반드시 제공하거나, ObjectOutputStream.writeUnshared와 ObjectInputStream.readUnshared 메서드를 사용해야 한다. 그렇지 않으면 공격자가 이 클래스로부터 가변 인스턴스를 만들어 낼 수 있다.

## ✏️핵심 정리

1. getter가 있다고 무조건 setter를 만들지 말자.
2. 클래스는 꼭 필요한 경우가 아니라면 불면이어야 한다.
→ 성능 때문에 어쩔 수 없다면 불변클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하자.
3. 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.

    → 꼭 변경해야 할 필드를 뺀 나머지 모두를 final로 선언하자.

4. 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
5. 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
→ 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공하면 안 된다.